#!/usr/bin/python

# Copyright (C) 2013 Canonical Ltd.

# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.

# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

from __future__ import print_function
import glob
import os
import os.path
import sys

sys.path.insert(1, os.path.join("@CMAKE_SOURCE_DIR@", "build", "python"))
from oxide_utils import CHROMIUMSRCDIR, TOPSRCDIR, CheckCall

sys.path.insert(0, os.path.join(CHROMIUMSRCDIR, 'tools', 'gyp', 'pylib'))
try:
    import gyp
except ImportError:
    print('Cannot find gyp module. Do you have a Chromium checkout?', file=sys.stderr)
    sys.exit(1)

sys.path.insert(1, os.path.join(CHROMIUMSRCDIR, 'tools', 'grit'))
sys.path.insert(1, os.path.join(CHROMIUMSRCDIR, 'chrome', 'tools', 'build'))
sys.path.insert(1, os.path.join(CHROMIUMSRCDIR, 'third_party', 'WebKit', 'Source', 'build', 'scripts'))

def which(file):
    try:
        paths = os.environ["PATH"]
    except KeyError:
        paths = os.defpath

    for path in paths.split(":"):
        full = os.path.join(path, file)
        if os.access(full, os.F_OK | os.X_OK):
            return full

def setup_linker_path(ld, output_dir):
    # We want to link with gold. Ubuntu has '-fuse-ld=gold', but as this
    # is distro specific, we do something that is currently supportable
    # across distributions
    if os.access(os.path.join(output_dir, 'gold', ld),
                 os.F_OK | os.F_OK):
        return

    try:
        os.makedirs(os.path.join(output_dir, 'gold'))
    except:
        pass

    gold = which('%s.gold' % ld)
    if not gold:
        gold = which(ld)
        if oxide_utils.CheckCall([gold, '-v']).find('gold') == -1:
            gold = None

    if not gold:
        print('Cannot find gold linker', file=sys.stderr)
        sys.exit(1)

    os.symlink(gold, os.path.join(output_dir, 'gold', ld))

def additional_include_files(args=[]):
    specified_includes = set()
    for arg in args:
        if arg.startswith('-I') and len(arg) > 2:
            specified_includes.add(os.path.realpath(arg[2:]))

    result = []
    def AddInclude(path):
        if os.path.realpath(path) not in specified_includes:
            result.append(path)

    # Always include common.gypi from Oxide
    AddInclude(os.path.join(TOPSRCDIR, 'build', 'common.gypi'))

    # Always include common.gypi from Chromium
    AddInclude(os.path.join(CHROMIUMSRCDIR, 'build', 'common.gypi'))

    # Always include share.gypi
    AddInclude(os.path.join(TOPSRCDIR, 'shared', 'shared.gypi'))

    # Optionally add supplemental .gypi files if present.
    supplements = glob.glob(os.path.join(CHROMIUMSRCDIR, '*', 'supplement.gypi'))
    for supplement in supplements:
        AddInclude(supplement)

    return result

def main(args):
    output_dir = "@CHROMIUM_OUTPUT_DIR@"
    pkg_config_path = "@CHROMIUM_PKG_CONFIG_PATH@"
    ld = "@CHROMIUM_LINKER@"

    if output_dir == "":
      output_dir = os.path.join(CHROMIUMSRCDIR, "out")
    if pkg_config_path != "":
      os.environ["PKG_CONFIG_PATH"] = pkg_config_path
    if ld == "":
      ld = "ld"

    setup_linker_path(ld, output_dir)

    args.append(os.path.join(TOPSRCDIR, 'build', 'all.gyp'))

    args.extend(['-I' + i for i in additional_include_files(args)])

    args.append('--no-circular-check')
    args.extend(['--toplevel-dir', TOPSRCDIR])
    args.extend(['--depth', CHROMIUMSRCDIR])
    args.extend(['--format', 'make'])
    args.append('-Goutput_dir=%s' % output_dir)

    os.chdir(TOPSRCDIR)
    sys.exit(gyp.main(args))

if __name__ == "__main__":
  main(sys.argv[1:])
