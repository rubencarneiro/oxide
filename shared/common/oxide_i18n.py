#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
Parse webkit_strings_en-US.rc and output a header file containing
a function that maps message IDs to gettext-localized strings.
"""

import argparse
import codecs
import os.path
import re

def parse_webkit_strings_rc(webkit_strings_rc):
  msgs = {}
  with codecs.open(webkit_strings_rc, encoding='utf-16') as f:
    msgs_re = re.compile('\\s*([A-Z_]+)\\s+(".*")')
    for line in f.readlines():
      match = msgs_re.match(line)
      if match is not None:
        msgs[match.group(1)] = match.group(2)
  return msgs

def output_strings_header(filename, msgs):
  cases = ''
  for k, v in msgs.iteritems():
    cases += u'  case {0}:\n    return C::gettext({1});\n'.format(k, v)
  cases += u'  default:\n    return "";'
  return u"""// This file is automatically generated from {filename}.
// Do not edit.

#ifndef {guard}
#define {guard}

namespace C {{
#include <libintl.h>
}}

#include "webkit/grit/webkit_strings.h"

static const char* localized_message_from_id(int message_id) {{
  switch(message_id) {{
{cases}
  }}
}}

#endif // {guard}
""".format(filename=filename, cases=cases, guard='_OXIDE_I18N_MESSAGES_H_')

def write_output_to_file(output, filepath):
  with codecs.open(filepath, encoding='utf-8', mode='w') as f:
    f.write(output)

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('-i', dest='input', required=True)
  parser.add_argument('-o', dest='output', required=True)
  args = parser.parse_args()
  msgs = parse_webkit_strings_rc(args.input)
  filename = os.path.basename(args.input)
  output = output_strings_header(filename, msgs)
  write_output_to_file(output, args.output)
