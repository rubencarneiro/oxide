# Description: Set the API to GLES rather than OpenGL when binding and
#  creating contexts. The Ubuntu QPA plugin explicitly selects OpenGL on
#  desktop, but we depend on GLES for surfaceless contexts
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/ui/gl/gl_context_egl.cc b/ui/gl/gl_context_egl.cc
--- a/ui/gl/gl_context_egl.cc
+++ b/ui/gl/gl_context_egl.cc
@@ -57,16 +57,18 @@ bool GLContextEGL::Initialize(
     context_attributes = kContextRobustnessAttributes;
   } else {
     // At some point we should require the presence of the robustness
     // extension and remove this code path.
     DVLOG(1) << "EGL_EXT_create_context_robustness NOT supported.";
     context_attributes = kContextAttributes;
   }
 
+  eglBindAPI(EGL_OPENGL_ES_API);
+
   context_ = eglCreateContext(
       display_,
       config_,
       share_group() ? share_group()->GetHandle() : NULL,
       context_attributes);
 
   if (!context_) {
     LOG(ERROR) << "eglCreateContext failed with error "
@@ -88,16 +90,18 @@ void GLContextEGL::Destroy() {
   }
 }
 
 bool GLContextEGL::MakeCurrent(GLSurface* surface) {
   DCHECK(context_);
   if (IsCurrent(surface))
       return true;
 
+  eglBindAPI(EGL_OPENGL_ES_API);
+
   ScopedReleaseCurrent release_current;
   TRACE_EVENT2("gpu", "GLContextEGL::MakeCurrent",
                "context", context_,
                "surface", surface);
 
   if (unbind_fbo_on_makecurrent_ &&
       eglGetCurrentContext() != EGL_NO_CONTEXT) {
     glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
@@ -132,29 +136,33 @@ bool GLContextEGL::MakeCurrent(GLSurface
 void GLContextEGL::SetUnbindFboOnMakeCurrent() {
   unbind_fbo_on_makecurrent_ = true;
 }
 
 void GLContextEGL::ReleaseCurrent(GLSurface* surface) {
   if (!IsCurrent(surface))
     return;
 
+  eglBindAPI(EGL_OPENGL_ES_API);
+
   if (unbind_fbo_on_makecurrent_)
     glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
 
   SetCurrent(NULL);
   eglMakeCurrent(display_,
                  EGL_NO_SURFACE,
                  EGL_NO_SURFACE,
                  EGL_NO_CONTEXT);
 }
 
 bool GLContextEGL::IsCurrent(GLSurface* surface) {
   DCHECK(context_);
 
+  eglBindAPI(EGL_OPENGL_ES_API);
+
   bool native_context_is_current = context_ == eglGetCurrentContext();
 
   // If our context is current then our notion of which GLContext is
   // current must be correct. On the other hand, third-party code
   // using OpenGL might change the current context.
   DCHECK(!native_context_is_current || (GetRealCurrent() == this));
 
   if (!native_context_is_current)
