# Description: Add WebContentsObserver::FrameAttached(), which is the opposite of
#  the existing FrameDetached()
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/content/browser/frame_host/frame_tree.cc b/content/browser/frame_host/frame_tree.cc
--- a/content/browser/frame_host/frame_tree.cc
+++ b/content/browser/frame_host/frame_tree.cc
@@ -111,16 +111,22 @@ RenderFrameHostImpl* FrameTree::AddFrame
                                          int new_routing_id,
                                          const std::string& frame_name) {
   scoped_ptr<FrameTreeNode> node(new FrameTreeNode(
       this, parent->navigator(), render_frame_delegate_, render_view_delegate_,
       render_widget_delegate_, manager_delegate_, frame_name));
   FrameTreeNode* node_ptr = node.get();
   // AddChild is what creates the RenderFrameHost.
   parent->AddChild(node.Pass(), new_routing_id);
+  if (!on_frame_added_.is_null()) {
+    on_frame_added_.Run(
+        node_ptr->current_frame_host()->render_view_host(),
+        parent->current_frame_host()->GetRoutingID(),
+        node_ptr->current_frame_host()->GetRoutingID());
+  }
   return node_ptr->current_frame_host();
 }
 
 void FrameTree::RemoveFrame(FrameTreeNode* child) {
   FrameTreeNode* parent = child->parent();
   if (!parent) {
     NOTREACHED() << "Unexpected RemoveFrame call for main frame.";
     return;
@@ -164,16 +170,21 @@ void FrameTree::SetFocusedFrame(FrameTre
   focused_frame_tree_node_id_ = node->frame_tree_node_id();
 }
 
 void FrameTree::SetFrameRemoveListener(
     const base::Callback<void(RenderViewHostImpl*, int)>& on_frame_removed) {
   on_frame_removed_ = on_frame_removed;
 }
 
+void FrameTree::SetFrameAddListener(
+    const base::Callback<void(RenderViewHostImpl*, int, int)>& on_frame_added) {
+  on_frame_added_ = on_frame_added;
+}
+
 RenderViewHostImpl* FrameTree::CreateRenderViewHostForMainFrame(
     SiteInstance* site_instance,
     int routing_id,
     int main_frame_routing_id,
     bool swapped_out,
     bool hidden) {
   DCHECK(main_frame_routing_id != MSG_ROUTING_NONE);
   RenderViewHostMap::iterator iter =
diff --git a/content/browser/frame_host/frame_tree.h b/content/browser/frame_host/frame_tree.h
--- a/content/browser/frame_host/frame_tree.h
+++ b/content/browser/frame_host/frame_tree.h
@@ -95,16 +95,18 @@ class CONTENT_EXPORT FrameTree {
   void SetFocusedFrame(FrameTreeNode* node);
 
   // Allows a client to listen for frame removal.  The listener should expect
   // to receive the RenderViewHostImpl containing the frame and the renderer-
   // specific frame routing ID of the removed frame.
   // TODO(creis): These parameters will later change to be the RenderFrameHost.
   void SetFrameRemoveListener(
       const base::Callback<void(RenderViewHostImpl*, int)>& on_frame_removed);
+  void SetFrameAddListener(
+      const base::Callback<void(RenderViewHostImpl*, int, int)>& on_frame_added);
 
   // Creates a RenderViewHost for a new main frame RenderFrameHost in the given
   // |site_instance|.  The RenderViewHost will have its Shutdown method called
   // when all of the RenderFrameHosts using it are deleted.
   RenderViewHostImpl* CreateRenderViewHostForMainFrame(
       SiteInstance* site_instance,
       int routing_id,
       int main_frame_routing_id,
@@ -149,15 +151,16 @@ class CONTENT_EXPORT FrameTree {
   // their state is already gone away).
   RenderViewHostMultiMap render_view_host_pending_shutdown_map_;
 
   scoped_ptr<FrameTreeNode> root_;
 
   int64 focused_frame_tree_node_id_;
 
   base::Callback<void(RenderViewHostImpl*, int)> on_frame_removed_;
+  base::Callback<void(RenderViewHostImpl*, int, int)> on_frame_added_;
 
   DISALLOW_COPY_AND_ASSIGN(FrameTree);
 };
 
 }  // namespace content
 
 #endif  // CONTENT_BROWSER_FRAME_HOST_FRAME_TREE_H_
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -353,16 +353,19 @@ WebContentsImpl::WebContentsImpl(
       fullscreen_widget_routing_id_(MSG_ROUTING_NONE),
       is_subframe_(false),
       last_dialog_suppressed_(false) {
   for (size_t i = 0; i < g_created_callbacks.Get().size(); i++)
     g_created_callbacks.Get().at(i).Run(this);
   frame_tree_.SetFrameRemoveListener(
       base::Bind(&WebContentsImpl::OnFrameRemoved,
                  base::Unretained(this)));
+  frame_tree_.SetFrameAddListener(
+      base::Bind(&WebContentsImpl::OnFrameAdded,
+                 base::Unretained(this)));
 }
 
 WebContentsImpl::~WebContentsImpl() {
   is_being_destroyed_ = true;
 
   // If there is an interstitial page being shown, tell it to close down early
   // so that this contents will be alive enough to handle all the UI triggered
   // by that. <http://crbug.com/363564>
@@ -3978,16 +3981,25 @@ gfx::Size WebContentsImpl::GetSizeForNew
 
 void WebContentsImpl::OnFrameRemoved(
     RenderViewHostImpl* render_view_host,
     int frame_routing_id) {
    FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                      FrameDetached(render_view_host, frame_routing_id));
 }
 
+void WebContentsImpl::OnFrameAdded(
+    RenderViewHostImpl* render_view_host,
+    int parent_frame_routing_id,
+    int frame_routing_id) {
+  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
+                    FrameAttached(render_view_host, parent_frame_routing_id, frame_routing_id));
+
+}
+
 void WebContentsImpl::OnPreferredSizeChanged(const gfx::Size& old_size) {
   if (!delegate_)
     return;
   const gfx::Size new_size = GetPreferredSize();
   if (new_size != old_size)
     delegate_->UpdatePreferredSize(this, new_size);
 }
 
diff --git a/content/browser/web_contents/web_contents_impl.h b/content/browser/web_contents/web_contents_impl.h
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -856,16 +856,18 @@ class CONTENT_EXPORT WebContentsImpl
   // Clear all PowerSaveBlockers, leave power_save_blocker_ empty.
   void ClearAllPowerSaveBlockers();
 
   // Helper function to invoke WebContentsDelegate::GetSizeForNewRenderView().
   gfx::Size GetSizeForNewRenderView();
 
   void OnFrameRemoved(RenderViewHostImpl* render_view_host,
                       int frame_routing_id);
+  void OnFrameAdded(RenderViewHostImpl* render_view_host,
+                    int parent_frame_routing_id, int frame_routing_id);
 
   // Helper method that's called whenever |preferred_size_| or
   // |preferred_size_for_capture_| changes, to propagate the new value to the
   // |delegate_|.
   void OnPreferredSizeChanged(const gfx::Size& old_size);
 
   // Adds/removes a callback called on creation of each new WebContents.
   // Deprecated, about to remove.
diff --git a/content/public/browser/web_contents_observer.h b/content/public/browser/web_contents_observer.h
--- a/content/public/browser/web_contents_observer.h
+++ b/content/public/browser/web_contents_observer.h
@@ -231,16 +231,19 @@ class CONTENT_EXPORT WebContentsObserver
                                    const GURL& url,
                                    const Referrer& referrer,
                                    WindowOpenDisposition disposition,
                                    PageTransition transition,
                                    int64 source_frame_id) {}
 
   virtual void FrameDetached(RenderViewHost* render_view_host,
                              int64 frame_id) {}
+  virtual void FrameAttached(RenderViewHost* render_view_host,
+                             int64 parent_frame_id,
+                             int64 frame_id) {}
 
   // This method is invoked when the renderer has completed its first paint
   // after a non-empty layout.
   virtual void DidFirstVisuallyNonEmptyPaint() {}
 
   // These two methods correspond to the points in time when the spinner of the
   // tab starts and stops spinning.
   virtual void DidStartLoading(RenderViewHost* render_view_host) {}
