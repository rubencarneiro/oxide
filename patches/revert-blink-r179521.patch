# Description: Revert "Cleanup deadcode in Rendering"
#  https://chromium.googlesource.com/chromium/blink/+/25a48eab31ad4f0a54bcaea1ead2b0cc4dec74d2
#  This breaks popup menus in Oxide
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/third_party/WebKit/Source/core/html/HTMLSelectElement.cpp b/third_party/WebKit/Source/core/html/HTMLSelectElement.cpp
--- a/third_party/WebKit/Source/core/html/HTMLSelectElement.cpp
+++ b/third_party/WebKit/Source/core/html/HTMLSelectElement.cpp
@@ -172,16 +172,28 @@ bool HTMLSelectElement::valueMissing() c
         return false;
 
     int firstSelectionIndex = selectedIndex();
 
     // If a non-placeholer label option is selected (firstSelectionIndex > 0), it's not value-missing.
     return firstSelectionIndex < 0 || (!firstSelectionIndex && hasPlaceholderLabelOption());
 }
 
+void HTMLSelectElement::listBoxSelectItem(int listIndex, bool allowMultiplySelections, bool shift, bool fireOnChangeNow)
+{
+    if (!multiple())
+        optionSelectedByUser(listToOptionIndex(listIndex), fireOnChangeNow, false);
+    else {
+        updateSelectedState(listIndex, allowMultiplySelections, shift);
+        setNeedsValidityCheck();
+        if (fireOnChangeNow)
+            listBoxOnChange();
+    }
+}
+
 bool HTMLSelectElement::usesMenuList() const
 {
     if (RenderTheme::theme().delegatesMenuListRendering())
         return true;
 
     return !m_multiple && m_size <= 1;
 }
 
diff --git a/third_party/WebKit/Source/core/html/HTMLSelectElement.h b/third_party/WebKit/Source/core/html/HTMLSelectElement.h
--- a/third_party/WebKit/Source/core/html/HTMLSelectElement.h
+++ b/third_party/WebKit/Source/core/html/HTMLSelectElement.h
@@ -97,16 +97,18 @@ public:
     void setLength(unsigned, ExceptionState&);
 
     Element* namedItem(const AtomicString& name);
     Element* item(unsigned index);
 
     void scrollToSelection();
     void scrollTo(int listIndex);
 
+    void listBoxSelectItem(int listIndex, bool allowMultiplySelections, bool shift, bool fireOnChangeNow = true);
+
     bool canSelectAll() const;
     void selectAll();
     int listToOptionIndex(int listIndex) const;
     void listBoxOnChange();
     int optionToListIndex(int optionIndex) const;
     int activeSelectionStartListIndex() const;
     int activeSelectionEndListIndex() const;
     void setActiveSelectionAnchorIndex(int);
diff --git a/third_party/WebKit/Source/core/rendering/RenderBlock.cpp b/third_party/WebKit/Source/core/rendering/RenderBlock.cpp
--- a/third_party/WebKit/Source/core/rendering/RenderBlock.cpp
+++ b/third_party/WebKit/Source/core/rendering/RenderBlock.cpp
@@ -4490,16 +4490,33 @@ LayoutUnit RenderBlock::nextPageLogicalT
 
     // The logicalOffset is in our coordinate space.  We can add in our pushed offset.
     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset);
     if (pageBoundaryRule == ExcludePageBoundary)
         return logicalOffset + (remainingLogicalHeight ? remainingLogicalHeight : pageLogicalHeight);
     return logicalOffset + remainingLogicalHeight;
 }
 
+LayoutUnit RenderBlock::pageLogicalTopForOffset(LayoutUnit offset) const
+{
+    RenderView* renderView = view();
+    LayoutUnit firstPageLogicalTop = isHorizontalWritingMode() ? renderView->layoutState()->pageOffset().height() : renderView->layoutState()->pageOffset().width();
+    LayoutUnit blockLogicalTop = isHorizontalWritingMode() ? renderView->layoutState()->layoutOffset().height() : renderView->layoutState()->layoutOffset().width();
+
+    LayoutUnit cumulativeOffset = offset + blockLogicalTop;
+    RenderFlowThread* flowThread = flowThreadContainingBlock();
+    if (!flowThread) {
+        LayoutUnit pageLogicalHeight = renderView->layoutState()->pageLogicalHeight();
+        if (!pageLogicalHeight)
+            return 0;
+        return cumulativeOffset - roundToInt(cumulativeOffset - firstPageLogicalTop) % roundToInt(pageLogicalHeight);
+    }
+    return flowThread->pageLogicalTopForOffset(cumulativeOffset);
+}
+
 LayoutUnit RenderBlock::pageLogicalHeightForOffset(LayoutUnit offset) const
 {
     RenderView* renderView = view();
     RenderFlowThread* flowThread = flowThreadContainingBlock();
     if (!flowThread)
         return renderView->layoutState()->pageLogicalHeight();
     return flowThread->pageLogicalHeightForOffset(offset + offsetFromLogicalTopOfFirstPage());
 }
diff --git a/third_party/WebKit/Source/core/rendering/RenderBlock.h b/third_party/WebKit/Source/core/rendering/RenderBlock.h
--- a/third_party/WebKit/Source/core/rendering/RenderBlock.h
+++ b/third_party/WebKit/Source/core/rendering/RenderBlock.h
@@ -451,16 +451,17 @@ protected:
     //
     // For a page height of 800px, the first rule will return 800 if the value passed in is 0. The second rule will simply return 0.
     enum PageBoundaryRule { ExcludePageBoundary, IncludePageBoundary };
     LayoutUnit nextPageLogicalTop(LayoutUnit logicalOffset, PageBoundaryRule = ExcludePageBoundary) const;
 
     bool createsBlockFormattingContext() const;
 
 public:
+    LayoutUnit pageLogicalTopForOffset(LayoutUnit offset) const;
     LayoutUnit pageLogicalHeightForOffset(LayoutUnit offset) const;
     LayoutUnit pageRemainingLogicalHeightForOffset(LayoutUnit offset, PageBoundaryRule = IncludePageBoundary) const;
 
 protected:
     // A page break is required at some offset due to space shortage in the current fragmentainer.
     void setPageBreak(LayoutUnit offset, LayoutUnit spaceShortage);
 
     // Update minimum page height required to avoid fragmentation where it shouldn't occur (inside
diff --git a/third_party/WebKit/Source/core/rendering/RenderFlowThread.cpp b/third_party/WebKit/Source/core/rendering/RenderFlowThread.cpp
--- a/third_party/WebKit/Source/core/rendering/RenderFlowThread.cpp
+++ b/third_party/WebKit/Source/core/rendering/RenderFlowThread.cpp
@@ -170,16 +170,22 @@ void RenderFlowThread::repaintRectangleI
 
     for (RenderMultiColumnSetList::const_iterator iter = m_multiColumnSetList.begin(); iter != m_multiColumnSetList.end(); ++iter) {
         RenderMultiColumnSet* columnSet = *iter;
 
         columnSet->repaintFlowThreadContent(repaintRect);
     }
 }
 
+LayoutUnit RenderFlowThread::pageLogicalTopForOffset(LayoutUnit offset)
+{
+    RenderMultiColumnSet* columnSet = columnSetAtBlockOffset(offset);
+    return columnSet ? columnSet->pageLogicalTopForOffset(offset) : LayoutUnit();
+}
+
 LayoutUnit RenderFlowThread::pageLogicalHeightForOffset(LayoutUnit offset)
 {
     RenderMultiColumnSet* columnSet = columnSetAtBlockOffset(offset);
     if (!columnSet)
         return 0;
 
     return columnSet->pageLogicalHeight();
 }
diff --git a/third_party/WebKit/Source/core/rendering/RenderFlowThread.h b/third_party/WebKit/Source/core/rendering/RenderFlowThread.h
--- a/third_party/WebKit/Source/core/rendering/RenderFlowThread.h
+++ b/third_party/WebKit/Source/core/rendering/RenderFlowThread.h
@@ -77,16 +77,17 @@ public:
     bool hasRegions() const { return m_multiColumnSetList.size(); }
 
     void validateRegions();
     void invalidateRegions();
     bool hasValidRegionInfo() const { return !m_regionsInvalidated && !m_multiColumnSetList.isEmpty(); }
 
     void repaintRectangleInRegions(const LayoutRect&) const;
 
+    LayoutUnit pageLogicalTopForOffset(LayoutUnit);
     LayoutUnit pageLogicalHeightForOffset(LayoutUnit);
     LayoutUnit pageRemainingLogicalHeightForOffset(LayoutUnit, PageBoundaryRule = IncludePageBoundary);
 
     virtual void setPageBreak(LayoutUnit /*offset*/, LayoutUnit /*spaceShortage*/) { }
     virtual void updateMinimumPageHeight(LayoutUnit /*offset*/, LayoutUnit /*minHeight*/) { }
 
     bool regionsHaveUniformLogicalHeight() const { return m_regionsHaveUniformLogicalHeight; }
 
diff --git a/third_party/WebKit/Source/core/rendering/RenderImage.h b/third_party/WebKit/Source/core/rendering/RenderImage.h
--- a/third_party/WebKit/Source/core/rendering/RenderImage.h
+++ b/third_party/WebKit/Source/core/rendering/RenderImage.h
@@ -48,16 +48,18 @@ public:
 
     bool setImageSizeForAltText(ImageResource* newImage = 0);
 
     void updateAltText();
 
     HTMLMapElement* imageMap() const;
     void areaElementFocusChanged(HTMLAreaElement*);
 
+    void highQualityRepaintTimerFired(Timer<RenderImage>*);
+
     void setIsGeneratedContent(bool generated = true) { m_isGeneratedContent = generated; }
 
     bool isGeneratedContent() const { return m_isGeneratedContent; }
 
     String altText() const { return m_altText; }
 
     inline void setImageDevicePixelRatio(float factor) { m_imageDevicePixelRatio = factor; }
     float imageDevicePixelRatio() const { return m_imageDevicePixelRatio; }
diff --git a/third_party/WebKit/Source/core/rendering/RenderListMarker.cpp b/third_party/WebKit/Source/core/rendering/RenderListMarker.cpp
--- a/third_party/WebKit/Source/core/rendering/RenderListMarker.cpp
+++ b/third_party/WebKit/Source/core/rendering/RenderListMarker.cpp
@@ -1673,16 +1673,37 @@ LayoutUnit RenderListMarker::lineHeight(
 int RenderListMarker::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
 {
     ASSERT(linePositionMode == PositionOnContainingLine);
     if (!isImage())
         return m_listItem->baselinePosition(baselineType, firstLine, direction, PositionOfInteriorLineBoxes);
     return RenderBox::baselinePosition(baselineType, firstLine, direction, linePositionMode);
 }
 
+String RenderListMarker::suffix() const
+{
+    EListStyleType type = style()->listStyleType();
+    const UChar suffix = listMarkerSuffix(type, m_listItem->value());
+
+    if (suffix == ' ')
+        return String(" ");
+
+    // If the suffix is not ' ', an extra space is needed
+    UChar data[2];
+    if (style()->isLeftToRightDirection()) {
+        data[0] = suffix;
+        data[1] = ' ';
+    } else {
+        data[0] = ' ';
+        data[1] = suffix;
+    }
+
+    return String(data, 2);
+}
+
 bool RenderListMarker::isInside() const
 {
     return m_listItem->notInList() || style()->listStylePosition() == INSIDE;
 }
 
 IntRect RenderListMarker::getRelativeMarkerRect()
 {
     if (isImage())
diff --git a/third_party/WebKit/Source/core/rendering/RenderListMarker.h b/third_party/WebKit/Source/core/rendering/RenderListMarker.h
--- a/third_party/WebKit/Source/core/rendering/RenderListMarker.h
+++ b/third_party/WebKit/Source/core/rendering/RenderListMarker.h
@@ -36,16 +36,17 @@ String listMarkerText(EListStyleType, in
 class RenderListMarker FINAL : public RenderBox {
 public:
     static RenderListMarker* createAnonymous(RenderListItem*);
 
     virtual ~RenderListMarker();
     virtual void trace(Visitor*) OVERRIDE;
 
     const String& text() const { return m_text; }
+    String suffix() const;
 
     bool isInside() const;
 
     void updateMarginsAndContent();
 
 private:
     RenderListMarker(RenderListItem*);
 
diff --git a/third_party/WebKit/Source/core/rendering/RenderMenuList.cpp b/third_party/WebKit/Source/core/rendering/RenderMenuList.cpp
--- a/third_party/WebKit/Source/core/rendering/RenderMenuList.cpp
+++ b/third_party/WebKit/Source/core/rendering/RenderMenuList.cpp
@@ -397,16 +397,21 @@ void RenderMenuList::valueChanged(unsign
     Document& doc = toElement(node())->document();
     if (&doc != doc.frame()->document())
         return;
 
     HTMLSelectElement* select = selectElement();
     select->optionSelectedByUser(select->listToOptionIndex(listIndex), fireOnChange);
 }
 
+void RenderMenuList::listBoxSelectItem(int listIndex, bool allowMultiplySelections, bool shift, bool fireOnChangeNow)
+{
+    selectElement()->listBoxSelectItem(listIndex, allowMultiplySelections, shift, fireOnChangeNow);
+}
+
 bool RenderMenuList::multiple() const
 {
     return selectElement()->multiple();
 }
 
 void RenderMenuList::didSetSelectedIndex(int listIndex)
 {
     didUpdateActiveOption(selectElement()->listToOptionIndex(listIndex));
diff --git a/third_party/WebKit/Source/core/rendering/RenderMenuList.h b/third_party/WebKit/Source/core/rendering/RenderMenuList.h
--- a/third_party/WebKit/Source/core/rendering/RenderMenuList.h
+++ b/third_party/WebKit/Source/core/rendering/RenderMenuList.h
@@ -90,16 +90,17 @@ private:
     virtual LayoutUnit clientPaddingRight() const OVERRIDE;
     virtual int listSize() const OVERRIDE;
     virtual int selectedIndex() const OVERRIDE;
     virtual void popupDidHide() OVERRIDE;
     virtual bool itemIsSeparator(unsigned listIndex) const OVERRIDE;
     virtual bool itemIsLabel(unsigned listIndex) const OVERRIDE;
     virtual bool itemIsSelected(unsigned listIndex) const OVERRIDE;
     virtual void setTextFromItem(unsigned listIndex) OVERRIDE;
+    virtual void listBoxSelectItem(int listIndex, bool allowMultiplySelections, bool shift, bool fireOnChangeNow = true) OVERRIDE;
     virtual bool multiple() const OVERRIDE;
 
     virtual bool hasLineIfEmpty() const OVERRIDE { return true; }
 
     // Flexbox defines baselines differently than regular blocks.
     // For backwards compatibility, menulists need to do the regular block behavior.
     virtual int baselinePosition(FontBaseline baseline, bool firstLine, LineDirectionMode direction, LinePositionMode position) const OVERRIDE
     {
diff --git a/third_party/WebKit/Source/core/rendering/RenderRegion.cpp b/third_party/WebKit/Source/core/rendering/RenderRegion.cpp
--- a/third_party/WebKit/Source/core/rendering/RenderRegion.cpp
+++ b/third_party/WebKit/Source/core/rendering/RenderRegion.cpp
@@ -139,16 +139,28 @@ void RenderRegion::repaintFlowThreadCont
 
     // Now switch to the region's writing mode coordinate space and let it repaint itself.
     flipForWritingMode(clippedRect);
 
     // Issue the repaint.
     invalidatePaintRectangle(clippedRect);
 }
 
+LayoutUnit RenderRegion::logicalTopOfFlowThreadContentRect(const LayoutRect& rect) const
+{
+    ASSERT(isValid());
+    return flowThread()->isHorizontalWritingMode() ? rect.y() : rect.x();
+}
+
+LayoutUnit RenderRegion::logicalBottomOfFlowThreadContentRect(const LayoutRect& rect) const
+{
+    ASSERT(isValid());
+    return flowThread()->isHorizontalWritingMode() ? rect.maxY() : rect.maxX();
+}
+
 void RenderRegion::computeIntrinsicLogicalWidths(LayoutUnit& minLogicalWidth, LayoutUnit& maxLogicalWidth) const
 {
     if (!isValid()) {
         RenderBlockFlow::computeIntrinsicLogicalWidths(minLogicalWidth, maxLogicalWidth);
         return;
     }
 
     minLogicalWidth = m_flowThread->minPreferredLogicalWidth();
diff --git a/third_party/WebKit/Source/core/rendering/RenderRegion.h b/third_party/WebKit/Source/core/rendering/RenderRegion.h
--- a/third_party/WebKit/Source/core/rendering/RenderRegion.h
+++ b/third_party/WebKit/Source/core/rendering/RenderRegion.h
@@ -59,16 +59,21 @@ public:
     bool isLastRegion() const;
 
     // These methods represent the width and height of a "page" and for a RenderRegion they are just
     // the content width and content height of a region. For RenderMultiColumnSets, however, they
     // will be the width and height of a single column or page in the set.
     virtual LayoutUnit pageLogicalWidth() const;
     virtual LayoutUnit pageLogicalHeight() const;
 
+    LayoutUnit logicalTopOfFlowThreadContentRect(const LayoutRect&) const;
+    LayoutUnit logicalBottomOfFlowThreadContentRect(const LayoutRect&) const;
+    LayoutUnit logicalTopForFlowThreadContent() const { return logicalTopOfFlowThreadContentRect(flowThreadPortionRect()); };
+    LayoutUnit logicalBottomForFlowThreadContent() const { return logicalBottomOfFlowThreadContentRect(flowThreadPortionRect()); };
+
     virtual bool canHaveChildren() const OVERRIDE FINAL { return false; }
     virtual bool canHaveGeneratedChildren() const OVERRIDE FINAL { return true; }
 
     virtual const char* renderName() const OVERRIDE { return "RenderRegion"; }
 
 protected:
     virtual void computeIntrinsicLogicalWidths(LayoutUnit& minLogicalWidth, LayoutUnit& maxLogicalWidth) const OVERRIDE FINAL;
 
