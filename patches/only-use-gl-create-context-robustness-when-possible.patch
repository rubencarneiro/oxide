# Description: Don't create contexts with EGL_EXT_create_context_robustness or
#  GLX_ARB_create_context_robustness if the application share context wasn't
#  created with it. Contexts created by Qt don't use these, and it's not
#  possible to mix them within a share group
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/ui/gl/gl_context_egl.cc b/ui/gl/gl_context_egl.cc
--- a/ui/gl/gl_context_egl.cc
+++ b/ui/gl/gl_context_egl.cc
@@ -26,17 +26,18 @@ using ui::GetLastEGLErrorString;
 namespace gfx {
 
 GLContextEGL::GLContextEGL(GLShareGroup* share_group)
     : GLContextReal(share_group),
       context_(nullptr),
       display_(nullptr),
       config_(nullptr),
       unbind_fbo_on_makecurrent_(false),
-      swap_interval_(1) {
+      swap_interval_(1),
+      was_allocated_using_robustness_extension_(false) {
 }
 
 bool GLContextEGL::Initialize(
     GLSurface* compatible_surface, GpuPreference gpu_preference) {
   DCHECK(compatible_surface);
   DCHECK(!context_);
 
   EGLint context_client_version = 2;
@@ -55,18 +56,21 @@ bool GLContextEGL::Initialize(
     EGL_LOSE_CONTEXT_ON_RESET_EXT,
     EGL_NONE
   };
 
   display_ = compatible_surface->GetDisplay();
   config_ = compatible_surface->GetConfig();
 
   const EGLint* context_attributes = nullptr;
-  if (GLSurfaceEGL::IsCreateContextRobustnessSupported()) {
+  if (GLSurfaceEGL::IsCreateContextRobustnessSupported() &&
+      (!share_group()->GetContext() ||
+       share_group()->GetContext()->WasAllocatedUsingRobustnessExtension())) {
     DVLOG(1) << "EGL_EXT_create_context_robustness supported.";
+    was_allocated_using_robustness_extension_ = true;
     context_attributes = kContextRobustnessAttributes;
   } else {
     // At some point we should require the presence of the robustness
     // extension and remove this code path.
     DVLOG(1) << "EGL_EXT_create_context_robustness NOT supported.";
     context_attributes = kContextAttributes;
   }
 
@@ -204,17 +208,17 @@ std::string GLContextEGL::GetExtensions(
                                           EGL_EXTENSIONS);
   if (!extensions)
     return GLContext::GetExtensions();
 
   return GLContext::GetExtensions() + " " + extensions;
 }
 
 bool GLContextEGL::WasAllocatedUsingRobustnessExtension() {
-  return GLSurfaceEGL::IsCreateContextRobustnessSupported();
+  return was_allocated_using_robustness_extension_;
 }
 
 GLContextEGL::~GLContextEGL() {
   Destroy();
 }
 
 #if !defined(OS_ANDROID)
 bool GLContextEGL::GetTotalGpuMemory(size_t* bytes) {
diff --git a/ui/gl/gl_context_egl.h b/ui/gl/gl_context_egl.h
--- a/ui/gl/gl_context_egl.h
+++ b/ui/gl/gl_context_egl.h
@@ -42,15 +42,16 @@ class GLContextEGL : public GLContextRea
  private:
   void Destroy();
 
   EGLContext context_;
   EGLDisplay display_;
   EGLConfig config_;
   bool unbind_fbo_on_makecurrent_;
   int swap_interval_;
+  bool was_allocated_using_robustness_extension_;
 
   DISALLOW_COPY_AND_ASSIGN(GLContextEGL);
 };
 
 }  // namespace gfx
 
 #endif  // UI_GL_GL_CONTEXT_EGL_H_
diff --git a/ui/gl/gl_context_glx.cc b/ui/gl/gl_context_glx.cc
--- a/ui/gl/gl_context_glx.cc
+++ b/ui/gl/gl_context_glx.cc
@@ -17,35 +17,39 @@ extern "C" {
 #include "ui/gl/gl_implementation.h"
 #include "ui/gl/gl_surface_glx.h"
 
 namespace gfx {
 
 GLContextGLX::GLContextGLX(GLShareGroup* share_group)
   : GLContextReal(share_group),
     context_(nullptr),
-    display_(nullptr) {
+    display_(NULL),
+    was_allocated_using_robustness_extension_(false) {
 }
 
 XDisplay* GLContextGLX::display() {
   return display_;
 }
 
 bool GLContextGLX::Initialize(
     GLSurface* compatible_surface, GpuPreference gpu_preference) {
   display_ = static_cast<XDisplay*>(compatible_surface->GetDisplay());
 
   GLXContext share_handle = static_cast<GLXContext>(
       share_group() ? share_group()->GetHandle() : nullptr);
 
   if (GLSurfaceGLX::IsCreateContextSupported()) {
     DVLOG(1) << "GLX_ARB_create_context supported.";
     std::vector<int> attribs;
-    if (GLSurfaceGLX::IsCreateContextRobustnessSupported()) {
+    if (GLSurfaceGLX::IsCreateContextRobustnessSupported() &&
+        (!share_group()->GetContext() ||
+         share_group()->GetContext()->WasAllocatedUsingRobustnessExtension())) {
       DVLOG(1) << "GLX_ARB_create_context_robustness supported.";
+      was_allocated_using_robustness_extension_ = true;
       attribs.push_back(GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB);
       attribs.push_back(GLX_LOSE_CONTEXT_ON_RESET_ARB);
     }
     attribs.push_back(0);
     context_ = glXCreateContextAttribsARB(
         display_,
         static_cast<GLXFBConfig>(compatible_surface->GetConfig()),
         share_handle,
@@ -202,16 +206,16 @@ bool GLContextGLX::GetTotalGpuMemory(siz
     *bytes =
         base::saturated_cast<size_t>(1024u * static_cast<uint64_t>(kbytes));
     return true;
   }
   return false;
 }
 
 bool GLContextGLX::WasAllocatedUsingRobustnessExtension() {
-  return GLSurfaceGLX::IsCreateContextRobustnessSupported();
+  return was_allocated_using_robustness_extension_;
 }
 
 GLContextGLX::~GLContextGLX() {
   Destroy();
 }
 
 }  // namespace gfx
diff --git a/ui/gl/gl_context_glx.h b/ui/gl/gl_context_glx.h
--- a/ui/gl/gl_context_glx.h
+++ b/ui/gl/gl_context_glx.h
@@ -38,15 +38,16 @@ class GL_EXPORT GLContextGLX : public GL
  protected:
   ~GLContextGLX() override;
 
  private:
   void Destroy();
 
   void* context_;
   XDisplay* display_;
+  bool was_allocated_using_robustness_extension_;
 
   DISALLOW_COPY_AND_ASSIGN(GLContextGLX);
 };
 
 }  // namespace gfx
 
 #endif  // UI_GL_GL_CONTEXT_GLX_H_
