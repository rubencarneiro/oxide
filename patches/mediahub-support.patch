diff --git a/content/public/renderer/content_renderer_client.cc b/content/public/renderer/content_renderer_client.cc
--- a/content/public/renderer/content_renderer_client.cc
+++ b/content/public/renderer/content_renderer_client.cc
@@ -208,9 +208,17 @@ BrowserPluginDelegate* ContentRendererCl
     const GURL& original_url) {
   return nullptr;
 }
 
 std::string ContentRendererClient::GetUserAgentOverrideForURL(const GURL& url) {
   return std::string();
 }
 
+blink::WebMediaPlayer* ContentRendererClient::OverrideWebMediaPlayer(
+    blink::WebFrame* frame,
+    blink::WebMediaPlayerClient* client,
+    base::WeakPtr<media::WebMediaPlayerDelegate> delegate,
+    media::MediaLog* media_log) {
+  return nullptr;
+}
+
 }  // namespace content
diff --git a/content/public/renderer/content_renderer_client.h b/content/public/renderer/content_renderer_client.h
--- a/content/public/renderer/content_renderer_client.h
+++ b/content/public/renderer/content_renderer_client.h
@@ -30,16 +30,18 @@ class SingleThreadTaskRunner;
 
 namespace blink {
 class WebAudioDevice;
 class WebClipboard;
 class WebFrame;
 class WebLocalFrame;
 class WebMIDIAccessor;
 class WebMIDIAccessorClient;
+class WebMediaPlayer;
+class WebMediaPlayerClient;
 class WebMediaStreamCenter;
 class WebMediaStreamCenterClient;
 class WebPlugin;
 class WebPluginContainer;
 class WebPluginPlaceholder;
 class WebPrescientNetworking;
 class WebRTCPeerConnectionHandler;
 class WebRTCPeerConnectionHandlerClient;
@@ -48,17 +50,19 @@ class WebSpeechSynthesizerClient;
 class WebThemeEngine;
 class WebURLRequest;
 class WebWorkerPermissionClientProxy;
 struct WebPluginParams;
 struct WebURLError;
 }
 
 namespace media {
+class MediaLog;
 class RendererFactory;
+class WebMediaPlayerDelegate;
 struct KeySystemInfo;
 }
 
 namespace content {
 class BrowserPluginDelegate;
 class DocumentState;
 class RenderFrame;
 class RenderView;
@@ -287,13 +291,20 @@ class CONTENT_EXPORT ContentRendererClie
   virtual bool IsPluginAllowedToUseCompositorAPI(const GURL& url);
 
   // Returns true if dev channel APIs are available for plugins.
   virtual bool IsPluginAllowedToUseDevChannelAPIs();
 
   // Returns a user agent override specific for |url|, or empty string if
   // default user agent should be used.
   virtual std::string GetUserAgentOverrideForURL(const GURL& url);
+
+  // Allow overriding default media player
+  virtual blink::WebMediaPlayer* OverrideWebMediaPlayer(
+      blink::WebFrame* frame,
+      blink::WebMediaPlayerClient* client,
+      base::WeakPtr<media::WebMediaPlayerDelegate> delegate,
+      media::MediaLog* media_log);
 };
 
 }  // namespace content
 
 #endif  // CONTENT_PUBLIC_RENDERER_CONTENT_RENDERER_CLIENT_H_
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -1910,16 +1910,25 @@ blink::WebMediaPlayer* RenderFrameImpl::
     media_permission_dispatcher_ = new MediaPermissionDispatcher(this);
 
 #if defined(OS_ANDROID)
   return CreateAndroidWebMediaPlayer(url, client, media_permission_dispatcher_,
                                      initial_cdm);
 #else
   scoped_refptr<media::MediaLog> media_log(new RenderMediaLog());
 
+  blink::WebMediaPlayer* media_player = 
+      GetContentClient()->renderer()->OverrideWebMediaPlayer(
+        frame_,
+        client,
+        weak_factory_.GetWeakPtr(),
+        media_log.get());
+
+  if (media_player)
+    return media_player; 
 
   RenderThreadImpl* render_thread = RenderThreadImpl::current();
   media::WebMediaPlayerParams params(
       base::Bind(&ContentRendererClient::DeferMediaLoad,
                  base::Unretained(GetContentClient()->renderer()),
                  static_cast<RenderFrame*>(this)),
       render_thread->GetAudioRendererMixerManager()->CreateInput(
           render_view_->routing_id_, routing_id_),
