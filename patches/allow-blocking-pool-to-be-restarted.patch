# HG changeset patch
# Parent fe61e06bfc85720c55ae89b8ac909849e9216c97
# User Chris Coulson <chris.coulson@canonical.com>

diff --git a/content/browser/browser_thread_impl.cc b/content/browser/browser_thread_impl.cc
--- a/content/browser/browser_thread_impl.cc
+++ b/content/browser/browser_thread_impl.cc
@@ -28,37 +28,44 @@ static const char* g_browser_thread_name
   "Chrome_FileUserBlockingThread",  // FILE_USER_BLOCKING
   "Chrome_ProcessLauncherThread",  // PROCESS_LAUNCHER
   "Chrome_CacheThread",  // CACHE
   "Chrome_IOThread",  // IO
 };
 
 struct BrowserThreadGlobals {
   BrowserThreadGlobals()
-      : blocking_pool(new base::SequencedWorkerPool(3, "BrowserBlocking")) {
+      : blocking_pool_(new base::SequencedWorkerPool(3, "BrowserBlocking")) {
     memset(threads, 0, BrowserThread::ID_COUNT * sizeof(threads[0]));
     memset(thread_delegates, 0,
            BrowserThread::ID_COUNT * sizeof(thread_delegates[0]));
   }
 
+  base::SequencedWorkerPool* blocking_pool() {
+    if (!blocking_pool_) {
+      blocking_pool_ = new base::SequencedWorkerPool(3, "BrowserBlocking");
+    }
+    return blocking_pool_;
+  }
+
   // This lock protects |threads|. Do not read or modify that array
   // without holding this lock. Do not block while holding this lock.
   base::Lock lock;
 
   // This array is protected by |lock|. The threads are not owned by this
   // array. Typically, the threads are owned on the UI thread by
   // BrowserMainLoop. BrowserThreadImpl objects remove themselves from this
   // array upon destruction.
   BrowserThreadImpl* threads[BrowserThread::ID_COUNT];
 
   // Only atomic operations are used on this array. The delegates are not owned
   // by this array, rather by whoever calls BrowserThread::SetDelegate.
   BrowserThreadDelegate* thread_delegates[BrowserThread::ID_COUNT];
 
-  const scoped_refptr<base::SequencedWorkerPool> blocking_pool;
+  scoped_refptr<base::SequencedWorkerPool> blocking_pool_;
 };
 
 base::LazyInstance<BrowserThreadGlobals>::Leaky
     g_globals = LAZY_INSTANCE_INITIALIZER;
 
 }  // namespace
 
 BrowserThreadImpl::BrowserThreadImpl(ID identifier)
@@ -77,25 +84,26 @@ BrowserThreadImpl::BrowserThreadImpl(ID 
 // static
 void BrowserThreadImpl::ShutdownThreadPool() {
   // The goal is to make it impossible for chrome to 'infinite loop' during
   // shutdown, but to reasonably expect that all BLOCKING_SHUTDOWN tasks queued
   // during shutdown get run. There's nothing particularly scientific about the
   // number chosen.
   const int kMaxNewShutdownBlockingTasks = 1000;
   BrowserThreadGlobals& globals = g_globals.Get();
-  globals.blocking_pool->Shutdown(kMaxNewShutdownBlockingTasks);
+  globals.blocking_pool()->Shutdown(kMaxNewShutdownBlockingTasks);
+  globals.blocking_pool_ = NULL;
 }
 
 // static
 void BrowserThreadImpl::FlushThreadPoolHelper() {
   // We don't want to create a pool if none exists.
   if (g_globals == NULL)
     return;
-  g_globals.Get().blocking_pool->FlushForTesting();
+  g_globals.Get().blocking_pool()->FlushForTesting();
 }
 
 void BrowserThreadImpl::Init() {
   BrowserThreadGlobals& globals = g_globals.Get();
 
   using base::subtle::AtomicWord;
   AtomicWord* storage =
       reinterpret_cast<AtomicWord*>(&globals.thread_delegates[identifier_]);
@@ -308,39 +316,39 @@ class BrowserThreadMessageLoopProxy : pu
   BrowserThread::ID id_;
   DISALLOW_COPY_AND_ASSIGN(BrowserThreadMessageLoopProxy);
 };
 
 // static
 bool BrowserThread::PostBlockingPoolTask(
     const tracked_objects::Location& from_here,
     const base::Closure& task) {
-  return g_globals.Get().blocking_pool->PostWorkerTask(from_here, task);
+  return g_globals.Get().blocking_pool()->PostWorkerTask(from_here, task);
 }
 
 bool BrowserThread::PostBlockingPoolTaskAndReply(
     const tracked_objects::Location& from_here,
     const base::Closure& task,
     const base::Closure& reply) {
-  return g_globals.Get().blocking_pool->PostTaskAndReply(
+  return g_globals.Get().blocking_pool()->PostTaskAndReply(
       from_here, task, reply);
 }
 
 // static
 bool BrowserThread::PostBlockingPoolSequencedTask(
     const std::string& sequence_token_name,
     const tracked_objects::Location& from_here,
     const base::Closure& task) {
-  return g_globals.Get().blocking_pool->PostNamedSequencedWorkerTask(
+  return g_globals.Get().blocking_pool()->PostNamedSequencedWorkerTask(
       sequence_token_name, from_here, task);
 }
 
 // static
 base::SequencedWorkerPool* BrowserThread::GetBlockingPool() {
-  return g_globals.Get().blocking_pool.get();
+  return g_globals.Get().blocking_pool();
 }
 
 // static
 bool BrowserThread::IsThreadInitialized(ID identifier) {
   if (g_globals == NULL)
     return false;
 
   BrowserThreadGlobals& globals = g_globals.Get();

