# Description: Add a ShouldDownloadUrl embedder hook to dispatch download requests.
# Author: Alexandre Abreu <alexandre.abreu@canonical.com>

diff --git a/content/browser/loader/buffered_resource_handler.cc b/content/browser/loader/buffered_resource_handler.cc
--- a/content/browser/loader/buffered_resource_handler.cc
+++ b/content/browser/loader/buffered_resource_handler.cc
@@ -5,16 +5,17 @@
 #include "content/browser/loader/buffered_resource_handler.h"
 
 #include <vector>
 
 #include "base/bind.h"
 #include "base/logging.h"
 #include "base/metrics/histogram.h"
 #include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
 #include "content/browser/download/download_resource_handler.h"
 #include "content/browser/download/download_stats.h"
 #include "content/browser/loader/certificate_resource_handler.h"
 #include "content/browser/loader/resource_dispatcher_host_impl.h"
 #include "content/browser/loader/resource_request_info_impl.h"
 #include "content/browser/loader/stream_resource_handler.h"
 #include "content/public/browser/content_browser_client.h"
 #include "content/public/browser/download_item.h"
@@ -349,16 +350,41 @@ bool BufferedResourceHandler::SelectNext
       *defer = true;
       return true;
     }
     if (has_plugin)
       return true;
 #endif
   }
 
+  if (host_->delegate()) {
+    std::string disposition;
+    request()->GetResponseHeaderByName("content-disposition", &disposition);
+    net::HttpContentDisposition content_disposition(disposition,
+                                                    std::string());
+    ResourceRequestInfoImpl* info = GetRequestInfo();
+    if (!host_->delegate()->ShouldDownloadUrl(
+            request()->url(),
+            request()->first_party_for_cookies(),
+            info->HasUserGesture(),
+            !disposition.empty() && (content_disposition.parse_result_flags() & net::HttpContentDisposition::HAS_FILENAME) ?
+              base::UTF8ToUTF16(content_disposition.filename()) : base::string16(),
+            false,
+            Referrer(GURL(request()->referrer()), info->GetReferrerPolicy()),
+            response_->head.mime_type,
+            info->GetChildID(),
+            info->GetRouteID(),
+            info->GetContext())) {
+      request()->Cancel();
+      Cancel();
+      LOG(INFO) << "Download request for " << request()->url().GetContent() << " got cancelled by embedder";
+      return false;
+    }
+  }
+
   // Install download handler
   info->set_is_download(true);
   scoped_ptr<ResourceHandler> handler(
       host_->CreateResourceHandlerForDownload(
           request(),
           true,  // is_content_initiated
           must_download,
           DownloadItem::kInvalidId,
diff --git a/content/browser/loader/resource_dispatcher_host_impl.cc b/content/browser/loader/resource_dispatcher_host_impl.cc
--- a/content/browser/loader/resource_dispatcher_host_impl.cc
+++ b/content/browser/loader/resource_dispatcher_host_impl.cc
@@ -599,16 +599,33 @@ DownloadInterruptReason ResourceDispatch
     scoped_ptr<DownloadSaveInfo> save_info,
     uint32 download_id,
     const DownloadStartedCallback& started_callback) {
   if (is_shutdown_)
     return CallbackAndReturn(started_callback,
                              DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN);
 
   const GURL& url = request->original_url();
+  if (delegate_) {
+    bool should_download_url = delegate_->ShouldDownloadUrl(
+      url,
+      request->first_party_for_cookies(),
+      is_content_initiated,
+      save_info->suggested_name,
+      save_info->prompt_for_save_location,
+      referrer,
+      std::string(), // mime_type
+      child_id,
+      route_id,
+      context);
+    if (!should_download_url) {
+      return CallbackAndReturn(started_callback,
+			       DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN);
+    }
+  }
 
   // http://crbug.com/90971
   char url_buf[128];
   base::strlcpy(url_buf, url.spec().c_str(), arraysize(url_buf));
   base::debug::Alias(url_buf);
   CHECK(ContainsKey(active_resource_contexts_, context));
 
   SetReferrerForRequest(request.get(), referrer);
diff --git a/content/public/browser/resource_dispatcher_host_delegate.cc b/content/public/browser/resource_dispatcher_host_delegate.cc
--- a/content/public/browser/resource_dispatcher_host_delegate.cc
+++ b/content/public/browser/resource_dispatcher_host_delegate.cc
@@ -80,15 +80,29 @@ void ResourceDispatcherHostDelegate::OnR
     ResourceContext* resource_context,
     ResourceResponse* response) {
 }
 
 void ResourceDispatcherHostDelegate::RequestComplete(
     net::URLRequest* url_request) {
 }
 
+bool ResourceDispatcherHostDelegate::ShouldDownloadUrl(
+    const GURL& url,
+    const GURL& first_party_url,
+    bool is_content_initiated,
+    const base::string16& suggested_name,
+    const bool use_prompt,
+    const Referrer& referrer,
+    const std::string& mime_type,
+    int render_process_id,
+    int render_view_id,
+    ResourceContext* resource_context) {
+  return true;
+}
+
 ResourceDispatcherHostDelegate::ResourceDispatcherHostDelegate() {
 }
 
 ResourceDispatcherHostDelegate::~ResourceDispatcherHostDelegate() {
 }
 
 }  // namespace content
diff --git a/content/public/browser/resource_dispatcher_host_delegate.h b/content/public/browser/resource_dispatcher_host_delegate.h
--- a/content/public/browser/resource_dispatcher_host_delegate.h
+++ b/content/public/browser/resource_dispatcher_host_delegate.h
@@ -4,16 +4,17 @@
 
 #ifndef CONTENT_PUBLIC_BROWSER_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
 #define CONTENT_PUBLIC_BROWSER_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
 
 #include <string>
 
 #include "base/basictypes.h"
 #include "base/memory/scoped_ptr.h"
+#include "base/strings/string16.h"
 #include "content/common/content_export.h"
 #include "content/public/common/resource_type.h"
 
 class GURL;
 template <class T> class ScopedVector;
 
 namespace IPC {
 class Sender;
@@ -112,16 +113,29 @@ class CONTENT_EXPORT ResourceDispatcherH
   virtual void OnRequestRedirected(const GURL& redirect_url,
                                    net::URLRequest* request,
                                    ResourceContext* resource_context,
                                    ResourceResponse* response);
 
   // Notification that a request has completed.
   virtual void RequestComplete(net::URLRequest* url_request);
 
+  // Returns whether a given download request should be carried on.
+  virtual bool ShouldDownloadUrl(
+      const GURL& url,
+      const GURL& first_party_url,
+      bool is_content_initiated,
+      const base::string16& suggested_name,
+      const bool use_prompt,
+      const Referrer& referrer,
+      const std::string& mime_type,
+      int render_process_id,
+      int render_view_id,
+      ResourceContext* resource_context);
+
  protected:
   ResourceDispatcherHostDelegate();
   virtual ~ResourceDispatcherHostDelegate();
 };
 
 }  // namespace content
 
 #endif  // CONTENT_PUBLIC_BROWSER_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
