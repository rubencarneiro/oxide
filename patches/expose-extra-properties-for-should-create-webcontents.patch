# HG changeset patch
# Parent 08ea0f91e5df58c192c56c205a5f7ea62b483fbb
# User oxide

diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -1739,17 +1739,18 @@ void WebContentsImpl::CreateNewWindow(
   SessionStorageNamespaceImpl* session_storage_namespace_impl =
       static_cast<SessionStorageNamespaceImpl*>(session_storage_namespace);
   CHECK(session_storage_namespace_impl->IsFromContext(dom_storage_context));
 
   if (delegate_ &&
       !delegate_->ShouldCreateWebContents(
           this, route_id, main_frame_route_id, main_frame_widget_route_id,
           params.window_container_type, params.frame_name, params.target_url,
-          partition_id, session_storage_namespace)) {
+          partition_id, session_storage_namespace, params.disposition,
+          params.user_gesture)) {
     if (route_id != MSG_ROUTING_NONE &&
         !RenderViewHost::FromID(render_process_id, route_id)) {
       // If the embedder didn't create a WebContents for this route, we need to
       // delete the RenderView that had already been created.
       Send(new ViewMsg_Close(route_id));
     }
     GetRenderViewHost()->GetProcess()->ResumeRequestsForView(route_id);
     GetRenderViewHost()->GetProcess()->ResumeRequestsForView(
diff --git a/content/public/browser/web_contents_delegate.cc b/content/public/browser/web_contents_delegate.cc
--- a/content/public/browser/web_contents_delegate.cc
+++ b/content/public/browser/web_contents_delegate.cc
@@ -134,17 +134,19 @@ bool WebContentsDelegate::ShouldCreateWe
     WebContents* web_contents,
     int32_t route_id,
     int32_t main_frame_route_id,
     int32_t main_frame_widget_route_id,
     WindowContainerType window_container_type,
     const std::string& frame_name,
     const GURL& target_url,
     const std::string& partition_id,
-    SessionStorageNamespace* session_storage_namespace) {
+    SessionStorageNamespace* session_storage_namespace,
+    WindowOpenDisposition window_open_disposition,
+    bool user_gesture) {
   return true;
 }
 
 JavaScriptDialogManager* WebContentsDelegate::GetJavaScriptDialogManager(
     WebContents* source) {
   return nullptr;
 }
 
diff --git a/content/public/browser/web_contents_delegate.h b/content/public/browser/web_contents_delegate.h
--- a/content/public/browser/web_contents_delegate.h
+++ b/content/public/browser/web_contents_delegate.h
@@ -291,17 +291,19 @@ class CONTENT_EXPORT WebContentsDelegate
       WebContents* web_contents,
       int32_t route_id,
       int32_t main_frame_route_id,
       int32_t main_frame_widget_route_id,
       WindowContainerType window_container_type,
       const std::string& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      SessionStorageNamespace* session_storage_namespace);
+      SessionStorageNamespace* session_storage_namespace,
+      WindowOpenDisposition window_open_disposition,
+      bool user_gesture);
 
   // Notifies the delegate about the creation of a new WebContents. This
   // typically happens when popups are created.
   virtual void WebContentsCreated(WebContents* source_contents,
                                   int opener_render_frame_id,
                                   const std::string& frame_name,
                                   const GURL& target_url,
                                   WebContents* new_contents) {}
