# HG changeset patch
# Parent 161d10f64f67fd0b6a922d7a20145db5374eb48d
# User oxide

diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -1501,17 +1501,19 @@ void WebContentsImpl::CreateNewWindow(
 
   if (delegate_ &&
       !delegate_->ShouldCreateWebContents(this,
                                           route_id,
                                           params.window_container_type,
                                           params.frame_name,
                                           params.target_url,
                                           partition_id,
-                                          session_storage_namespace)) {
+                                          session_storage_namespace,
+                                          params.disposition,
+                                          params.user_gesture)) {
     if (route_id != MSG_ROUTING_NONE &&
         !RenderViewHost::FromID(render_process_id, route_id)) {
       // If the embedder didn't create a WebContents for this route, we need to
       // delete the RenderView that had already been created.
       Send(new ViewMsg_Close(route_id));
     }
     GetRenderViewHost()->GetProcess()->ResumeRequestsForView(route_id);
     GetRenderViewHost()->GetProcess()->ResumeRequestsForView(
diff --git a/content/public/browser/web_contents_delegate.cc b/content/public/browser/web_contents_delegate.cc
--- a/content/public/browser/web_contents_delegate.cc
+++ b/content/public/browser/web_contents_delegate.cc
@@ -131,17 +131,19 @@ bool WebContentsDelegate::OnGoToEntryOff
 
 bool WebContentsDelegate::ShouldCreateWebContents(
     WebContents* web_contents,
     int route_id,
     WindowContainerType window_container_type,
     const base::string16& frame_name,
     const GURL& target_url,
     const std::string& partition_id,
-    SessionStorageNamespace* session_storage_namespace) {
+    SessionStorageNamespace* session_storage_namespace,
+    WindowOpenDisposition window_open_disposition,
+    bool user_gesture) {
   return true;
 }
 
 JavaScriptDialogManager* WebContentsDelegate::GetJavaScriptDialogManager(
     WebContents* source) {
   return NULL;
 }
 
diff --git a/content/public/browser/web_contents_delegate.h b/content/public/browser/web_contents_delegate.h
--- a/content/public/browser/web_contents_delegate.h
+++ b/content/public/browser/web_contents_delegate.h
@@ -308,17 +308,19 @@ class CONTENT_EXPORT WebContentsDelegate
   // be destroyed.
   virtual bool ShouldCreateWebContents(
       WebContents* web_contents,
       int route_id,
       WindowContainerType window_container_type,
       const base::string16& frame_name,
       const GURL& target_url,
       const std::string& partition_id,
-      SessionStorageNamespace* session_storage_namespace);
+      SessionStorageNamespace* session_storage_namespace,
+      WindowOpenDisposition window_open_disposition,
+      bool user_gesture);
 
   // Notifies the delegate about the creation of a new WebContents. This
   // typically happens when popups are created.
   virtual void WebContentsCreated(WebContents* source_contents,
                                   int opener_render_frame_id,
                                   const base::string16& frame_name,
                                   const GURL& target_url,
                                   WebContents* new_contents) {}
