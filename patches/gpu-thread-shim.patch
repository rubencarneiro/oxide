# Description: Compile in our shim to allow Oxide to use non-exported
#  GPU related APIs from content. Also allow the application to provide
#  a shared GL context for texture sharing
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/content/common/gpu/gpu_channel_manager.cc b/content/common/gpu/gpu_channel_manager.cc
--- a/content/common/gpu/gpu_channel_manager.cc
+++ b/content/common/gpu/gpu_channel_manager.cc
@@ -20,16 +20,18 @@
 #include "gpu/command_buffer/service/mailbox_manager.h"
 #include "gpu/command_buffer/service/memory_program_cache.h"
 #include "gpu/command_buffer/service/shader_translator_cache.h"
 #include "gpu/command_buffer/service/sync_point_manager.h"
 #include "ipc/message_filter.h"
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_share_group.h"
 
+#include "shared/port/content/common/gpu_service_shim_oxide.h"
+
 namespace content {
 
 GpuChannelManager::GpuChannelManager(
     MessageRouter* router,
     GpuWatchdog* watchdog,
     base::SingleThreadTaskRunner* io_task_runner,
     base::WaitableEvent* shutdown_event,
     IPC::SyncChannel* channel,
@@ -128,17 +130,20 @@ void GpuChannelManager::OnEstablishChann
                                            bool share_context,
                                            bool allow_future_sync_points) {
   IPC::ChannelHandle channel_handle;
 
   gfx::GLShareGroup* share_group = NULL;
   gpu::gles2::MailboxManager* mailbox_manager = NULL;
   if (share_context) {
     if (!share_group_.get()) {
-      share_group_ = new gfx::GLShareGroup;
+      share_group_ = oxide_gpu_shim::GetGLShareGroup();
+      if (!share_group_.get()) {
+        share_group_ = new gfx::GLShareGroup;
+      }
       DCHECK(!mailbox_manager_.get());
       mailbox_manager_ = gpu::gles2::MailboxManager::Create();
     }
     share_group = share_group_.get();
     mailbox_manager = mailbox_manager_.get();
   }
 
   scoped_ptr<GpuChannel> channel(new GpuChannel(this,
diff --git a/content/content_common.gypi b/content/content_common.gypi
--- a/content/content_common.gypi
+++ b/content/content_common.gypi
@@ -19,16 +19,17 @@
     '../ui/gfx/gfx.gyp:gfx',
     '../ui/gfx/gfx.gyp:gfx_geometry',
     '../ui/gfx/ipc/gfx_ipc.gyp:gfx_ipc',
     '../ui/shell_dialogs/shell_dialogs.gyp:shell_dialogs',
     '../url/url.gyp:url_lib',
   ],
   'include_dirs': [
     '..',
+    '<(DEPTH)/../../..',
   ],
   'export_dependent_settings': [
     '../base/base.gyp:base',
     # The public content API headers directly include Blink API headers, so we
     # have to export the blink header settings so that relative paths in these
     # headers resolve correctly.
     '../third_party/WebKit/public/blink_headers.gyp:blink_headers',
     '../ui/accessibility/accessibility.gyp:ax_gen',
@@ -551,16 +552,20 @@
       'common/view_messages.h',
       'common/webplugin_geometry.cc',
       'common/webplugin_geometry.h',
       'common/websocket.cc',
       'common/websocket.h',
       'common/websocket_messages.h',
       'common/worker_messages.h',
       'common/zygote_commands_linux.h',
+      '<(DEPTH)/../../../shared/port/content/common/gpu_client_shim_oxide.cc',
+      '<(DEPTH)/../../../shared/port/content/common/gpu_client_shim_oxide.h',
+      '<(DEPTH)/../../../shared/port/content/common/gpu_service_shim_oxide.cc',
+      '<(DEPTH)/../../../shared/port/content/common/gpu_service_shim_oxide.h',
     ],
   },
   'sources': [
     '<@(public_common_sources)',
     '<@(private_common_sources)',
   ],
   'target_conditions': [
     ['OS=="android" and <(use_seccomp_bpf)==1', {
diff --git a/content/gpu/gpu_child_thread.cc b/content/gpu/gpu_child_thread.cc
--- a/content/gpu/gpu_child_thread.cc
+++ b/content/gpu/gpu_child_thread.cc
@@ -27,16 +27,21 @@
 #endif
 
 namespace content {
 namespace {
 
 static base::LazyInstance<scoped_refptr<ThreadSafeSender> >
     g_thread_safe_sender = LAZY_INSTANCE_INITIALIZER;
 
+static base::LazyInstance<base::ThreadLocalPointer<GpuChildThread> >
+    g_lazy_tls = LAZY_INSTANCE_INITIALIZER;
+static base::LazyInstance<scoped_refptr<base::SingleThreadTaskRunner> >
+    g_thread_safe_task_runner = LAZY_INSTANCE_INITIALIZER;
+
 bool GpuProcessLogMessageHandler(int severity,
                                  const char* file, int line,
                                  size_t message_start,
                                  const std::string& str) {
   std::string header = str.substr(0, message_start);
   std::string message = str.substr(message_start);
 
   g_thread_safe_sender.Get()->Send(new GpuHostMsg_OnLogMessage(
@@ -151,20 +156,37 @@ GpuChildThread::GpuChildThread(
   DCHECK(base::CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kSingleProcess) ||
          base::CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kInProcessGPU));
 
   if (!gfx::GLSurface::InitializeOneOff())
     VLOG(1) << "gfx::GLSurface::InitializeOneOff failed";
 
+  g_lazy_tls.Pointer()->Set(this);
   g_thread_safe_sender.Get() = thread_safe_sender();
+  g_thread_safe_task_runner.Get() = message_loop()->task_runner();
 }
 
 GpuChildThread::~GpuChildThread() {
+  g_lazy_tls.Pointer()->Set(NULL);
+}
+
+// static
+scoped_refptr<base::SingleThreadTaskRunner> GpuChildThread::GetTaskRunner() {
+  return g_thread_safe_task_runner.Get();
+}
+
+// static
+GpuChannelManager* GpuChildThread::GetChannelManager() {
+  GpuChildThread* inst = g_lazy_tls.Pointer()->Get();
+  if (!inst)
+    return NULL;
+
+  return inst->gpu_channel_manager_.get();
 }
 
 // static
 gfx::GpuMemoryBufferType GpuChildThread::GetGpuMemoryBufferFactoryType() {
   std::vector<gfx::GpuMemoryBufferType> supported_types;
   GpuMemoryBufferFactory::GetSupportedTypes(&supported_types);
   DCHECK(!supported_types.empty());
   // Note: We always use the preferred type.
diff --git a/content/gpu/gpu_child_thread.h b/content/gpu/gpu_child_thread.h
--- a/content/gpu/gpu_child_thread.h
+++ b/content/gpu/gpu_child_thread.h
@@ -17,16 +17,20 @@
 #include "content/child/child_thread_impl.h"
 #include "content/common/gpu/gpu_channel.h"
 #include "content/common/gpu/gpu_channel_manager.h"
 #include "content/common/gpu/gpu_config.h"
 #include "content/common/gpu/x_util.h"
 #include "gpu/config/gpu_info.h"
 #include "ui/gfx/native_widget_types.h"
 
+namespace base {
+class SingleThreadTaskRunner;
+}
+
 namespace gpu {
 class SyncPointManager;
 }
 
 namespace sandbox {
 class TargetServices;
 }
 
@@ -50,16 +54,19 @@ class GpuChildThread : public ChildThrea
                  gpu::SyncPointManager* sync_point_manager);
 
   GpuChildThread(const InProcessChildThreadParams& params,
                  GpuMemoryBufferFactory* gpu_memory_buffer_factory,
                  gpu::SyncPointManager* sync_point_manager);
 
   ~GpuChildThread() override;
 
+  CONTENT_EXPORT static scoped_refptr<base::SingleThreadTaskRunner> GetTaskRunner();
+  CONTENT_EXPORT static GpuChannelManager* GetChannelManager();
+
   static gfx::GpuMemoryBufferType GetGpuMemoryBufferFactoryType();
 
   void Shutdown() override;
 
   void Init(const base::Time& process_start_time);
   void StopWatchdog();
 
   // ChildThread overrides.
