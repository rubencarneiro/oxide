# Description: Compile in our shim to allow Oxide to use non-exported
#  GPU related APIs from content. Also allow the application to provide
#  a shared GL context for texture sharing
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/content/common/gpu/gpu_channel_manager.cc b/content/common/gpu/gpu_channel_manager.cc
--- a/content/common/gpu/gpu_channel_manager.cc
+++ b/content/common/gpu/gpu_channel_manager.cc
@@ -23,16 +23,18 @@
 #include "gpu/command_buffer/service/mailbox_manager.h"
 #include "gpu/command_buffer/service/memory_program_cache.h"
 #include "gpu/command_buffer/service/shader_translator_cache.h"
 #include "gpu/command_buffer/service/sync_point_manager.h"
 #include "ipc/message_filter.h"
 #include "ui/gl/gl_bindings.h"
 #include "ui/gl/gl_share_group.h"
 
+#include "shared/port/content/common/gpu_service_shim_oxide.h"
+
 namespace content {
 
 namespace {
 #if defined(OS_ANDROID)
 // Amount of time we expect the GPU to stay powered up without being used.
 const int kMaxGpuIdleTimeMs = 40;
 // Maximum amount of time we keep pinging the GPU waiting for the client to
 // draw.
@@ -49,31 +51,33 @@ GpuChannelManager::GpuChannelManager(
     base::WaitableEvent* shutdown_event,
     gpu::SyncPointManager* sync_point_manager,
     GpuMemoryBufferFactory* gpu_memory_buffer_factory)
     : task_runner_(task_runner),
       io_task_runner_(io_task_runner),
       channel_(channel),
       watchdog_(watchdog),
       shutdown_event_(shutdown_event),
-      share_group_(new gfx::GLShareGroup),
+      share_group_(oxide_gpu_shim::GetGLShareGroup()),
       mailbox_manager_(gpu::gles2::MailboxManager::Create()),
       gpu_memory_manager_(
           this,
           GpuMemoryManager::kDefaultMaxSurfacesWithFrontbufferSoftLimit),
       sync_point_manager_(sync_point_manager),
       sync_point_client_waiter_(new gpu::SyncPointClientWaiter),
       gpu_memory_buffer_factory_(gpu_memory_buffer_factory),
       weak_factory_(this) {
   DCHECK(task_runner);
   DCHECK(io_task_runner);
   const base::CommandLine* command_line =
       base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(switches::kUIPrioritizeInGpuProcess))
     preemption_flag_ = new gpu::PreemptionFlag;
+  if (!share_group_.get())
+    share_group_ = new gfx::GLShareGroup;
 }
 
 GpuChannelManager::~GpuChannelManager() {
   // Destroy channels before anything else because of dependencies.
   gpu_channels_.clear();
   if (default_offscreen_surface_.get()) {
     default_offscreen_surface_->Destroy();
     default_offscreen_surface_ = NULL;
diff --git a/content/common/gpu/gpu_channel_manager.h b/content/common/gpu/gpu_channel_manager.h
--- a/content/common/gpu/gpu_channel_manager.h
+++ b/content/common/gpu/gpu_channel_manager.h
@@ -110,27 +110,27 @@ class CONTENT_EXPORT GpuChannelManager :
   // Returns the maximum order number for processed IPC messages across all
   // channels.
   uint32_t GetProcessedOrderNum() const;
 
 #if defined(OS_ANDROID)
   void DidAccessGpu();
 #endif
 
+  gpu::SyncPointManager* sync_point_manager() const {
+    return sync_point_manager_;
+  }
+
  protected:
   virtual scoped_ptr<GpuChannel> CreateGpuChannel(int client_id,
                                                   uint64_t client_tracing_id,
                                                   bool preempts,
                                                   bool allow_future_sync_points,
                                                   bool allow_real_time_streams);
 
-  gpu::SyncPointManager* sync_point_manager() const {
-    return sync_point_manager_;
-  }
-
   gfx::GLShareGroup* share_group() const { return share_group_.get(); }
   gpu::gles2::MailboxManager* mailbox_manager() const {
     return mailbox_manager_.get();
   }
   gpu::PreemptionFlag* preemption_flag() const {
     return preemption_flag_.get();
   }
 
diff --git a/content/content_common.gypi b/content/content_common.gypi
--- a/content/content_common.gypi
+++ b/content/content_common.gypi
@@ -19,16 +19,17 @@
     '../ui/gfx/gfx.gyp:gfx',
     '../ui/gfx/gfx.gyp:gfx_geometry',
     '../ui/gfx/ipc/gfx_ipc.gyp:gfx_ipc',
     '../ui/shell_dialogs/shell_dialogs.gyp:shell_dialogs',
     '../url/url.gyp:url_lib',
   ],
   'include_dirs': [
     '..',
+    '<(DEPTH)/../../..',
   ],
   'export_dependent_settings': [
     '../base/base.gyp:base',
     # The public content API headers directly include Blink API headers, so we
     # have to export the blink header settings so that relative paths in these
     # headers resolve correctly.
     '../third_party/WebKit/public/blink_headers.gyp:blink_headers',
     '../ui/accessibility/accessibility.gyp:ax_gen',
@@ -554,16 +555,20 @@
       'common/view_messages.h',
       'common/webplugin_geometry.cc',
       'common/webplugin_geometry.h',
       'common/websocket.cc',
       'common/websocket.h',
       'common/websocket_messages.h',
       'common/worker_messages.h',
       'common/zygote_commands_linux.h',
+      '<(DEPTH)/../../../shared/port/content/common/gpu_client_shim_oxide.cc',
+      '<(DEPTH)/../../../shared/port/content/common/gpu_client_shim_oxide.h',
+      '<(DEPTH)/../../../shared/port/content/common/gpu_service_shim_oxide.cc',
+      '<(DEPTH)/../../../shared/port/content/common/gpu_service_shim_oxide.h',
     ],
   },
   'sources': [
     '<@(public_common_sources)',
     '<@(private_common_sources)',
   ],
   'target_conditions': [
     ['OS=="android" and <(use_seccomp_bpf)==1', {
diff --git a/content/gpu/gpu_child_thread.cc b/content/gpu/gpu_child_thread.cc
--- a/content/gpu/gpu_child_thread.cc
+++ b/content/gpu/gpu_child_thread.cc
@@ -28,16 +28,21 @@
 #endif
 
 namespace content {
 namespace {
 
 static base::LazyInstance<scoped_refptr<ThreadSafeSender> >
     g_thread_safe_sender = LAZY_INSTANCE_INITIALIZER;
 
+static base::LazyInstance<base::ThreadLocalPointer<GpuChildThread> >
+    g_lazy_tls = LAZY_INSTANCE_INITIALIZER;
+static base::LazyInstance<scoped_refptr<base::SingleThreadTaskRunner> >
+    g_thread_safe_task_runner = LAZY_INSTANCE_INITIALIZER;
+
 bool GpuProcessLogMessageHandler(int severity,
                                  const char* file, int line,
                                  size_t message_start,
                                  const std::string& str) {
   std::string header = str.substr(0, message_start);
   std::string message = str.substr(message_start);
 
   g_thread_safe_sender.Get()->Send(new GpuHostMsg_OnLogMessage(
@@ -168,26 +173,43 @@ GpuChildThread::GpuChildThread(
   DCHECK(base::CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kSingleProcess) ||
          base::CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kInProcessGPU));
 
   if (!gfx::GLSurface::InitializeOneOff())
     VLOG(1) << "gfx::GLSurface::InitializeOneOff failed";
 
+  g_lazy_tls.Pointer()->Set(this);
   g_thread_safe_sender.Get() = thread_safe_sender();
+  g_thread_safe_task_runner.Get() = message_loop()->task_runner();
 }
 
 GpuChildThread::~GpuChildThread() {
+  g_lazy_tls.Pointer()->Set(NULL);
   while (!deferred_messages_.empty()) {
     delete deferred_messages_.front();
     deferred_messages_.pop();
   }
 }
 
+// static
+scoped_refptr<base::SingleThreadTaskRunner> GpuChildThread::GetTaskRunner() {
+  return g_thread_safe_task_runner.Get();
+}
+
+// static
+GpuChannelManager* GpuChildThread::GetChannelManager() {
+  GpuChildThread* inst = g_lazy_tls.Pointer()->Get();
+  if (!inst)
+    return NULL;
+
+  return inst->gpu_channel_manager_.get();
+}
+
 void GpuChildThread::Shutdown() {
   ChildThreadImpl::Shutdown();
   logging::SetLogMessageHandler(NULL);
 }
 
 void GpuChildThread::Init(const base::Time& process_start_time) {
   process_start_time_ = process_start_time;
 
diff --git a/content/gpu/gpu_child_thread.h b/content/gpu/gpu_child_thread.h
--- a/content/gpu/gpu_child_thread.h
+++ b/content/gpu/gpu_child_thread.h
@@ -19,16 +19,20 @@
 #include "content/common/gpu/gpu_channel_manager.h"
 #include "content/common/gpu/gpu_config.h"
 #include "content/common/gpu/x_util.h"
 #include "gpu/config/gpu_info.h"
 #include "mojo/common/weak_binding_set.h"
 #include "third_party/mojo/src/mojo/public/cpp/bindings/interface_request.h"
 #include "ui/gfx/native_widget_types.h"
 
+namespace base {
+class SingleThreadTaskRunner;
+}
+
 namespace gpu {
 class SyncPointManager;
 }
 
 namespace sandbox {
 class TargetServices;
 }
 
@@ -54,16 +58,19 @@ class GpuChildThread : public ChildThrea
                  gpu::SyncPointManager* sync_point_manager);
 
   GpuChildThread(const InProcessChildThreadParams& params,
                  GpuMemoryBufferFactory* gpu_memory_buffer_factory,
                  gpu::SyncPointManager* sync_point_manager);
 
   ~GpuChildThread() override;
 
+  CONTENT_EXPORT static scoped_refptr<base::SingleThreadTaskRunner> GetTaskRunner();
+  CONTENT_EXPORT static GpuChannelManager* GetChannelManager();
+
   void Shutdown() override;
 
   void Init(const base::Time& process_start_time);
   void StopWatchdog();
 
   // ChildThread overrides.
   bool Send(IPC::Message* msg) override;
   bool OnControlMessageReceived(const IPC::Message& msg) override;
