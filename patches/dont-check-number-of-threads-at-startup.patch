# Description: Comment out the check which ensures that there is only one thread
#  before calling fork() for the sandbox. With Oxide, there will always be
#  more than one thread here, started and owned by the embedder. Whilst there are
#  issues with calling fork() from a process with multiple threads (see
#  http://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them),
#  this has always worked fine without this check and it's not something we
#  restrict in any other multi-threaded applications
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/content/browser/renderer_host/render_sandbox_host_linux.cc b/content/browser/renderer_host/render_sandbox_host_linux.cc
--- a/content/browser/renderer_host/render_sandbox_host_linux.cc
+++ b/content/browser/renderer_host/render_sandbox_host_linux.cc
@@ -706,17 +706,17 @@ void RenderSandboxHostLinux::Init(const 
   const int browser_socket = fds[1];
 
   int pipefds[2];
   CHECK(0 == pipe(pipefds));
   const int child_lifeline_fd = pipefds[0];
   childs_lifeline_fd_ = pipefds[1];
 
   // We need to be monothreaded before we fork().
-#if !defined(TOOLKIT_GTK) && !defined(THREAD_SANITIZER)
+#if 0
   // Exclude gtk port as TestSuite in base/tests/test_suite.cc is calling
   // gtk_init.
   // TODO(oshima): Remove ifdef when above issues are resolved.
   DCHECK_EQ(1, base::GetNumberOfThreads(base::GetCurrentProcessHandle()));
 #endif  // !defined(TOOLKIT_GTK) && !defined(THREAD_SANITIZER)
   pid_ = fork();
   if (pid_ == 0) {
     if (IGNORE_EINTR(close(fds[0])) < 0)
