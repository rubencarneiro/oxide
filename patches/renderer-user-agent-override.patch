# Description: Reach out to the embedder for a UA string override from
#  RenderFrameImpl::userAgentOverride(). This is called from Blink for
#  navigator.userAgent, and we already return an override from here
#  (which is our default)
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/content/public/renderer/content_renderer_client.cc b/content/public/renderer/content_renderer_client.cc
--- a/content/public/renderer/content_renderer_client.cc
+++ b/content/public/renderer/content_renderer_client.cc
@@ -191,9 +191,15 @@ bool ContentRendererClient::IsPluginAllo
 }
 
 BrowserPluginDelegate* ContentRendererClient::CreateBrowserPluginDelegate(
     RenderFrame* render_frame,
     const std::string& mime_type) {
   return NULL;
 }
 
+bool ContentRendererClient::GetUserAgentOverride(
+    const GURL& url,
+    std::string* user_agent) {
+  return false;
+}
+
 }  // namespace content
diff --git a/content/public/renderer/content_renderer_client.h b/content/public/renderer/content_renderer_client.h
--- a/content/public/renderer/content_renderer_client.h
+++ b/content/public/renderer/content_renderer_client.h
@@ -268,13 +268,16 @@ class CONTENT_EXPORT ContentRendererClie
   // Returns true if the page at |url| can use Pepper Compositor APIs.
   virtual bool IsPluginAllowedToUseCompositorAPI(const GURL& url);
 
   // Returns true if the page at |url| can use Pepper VideoDecoder APIs.
   virtual bool IsPluginAllowedToUseVideoDecodeAPI(const GURL& url);
 
   // Returns true if dev channel APIs are available for plugins.
   virtual bool IsPluginAllowedToUseDevChannelAPIs();
+
+  virtual bool GetUserAgentOverride(const GURL& url,
+                                    std::string* user_agent);
 };
 
 }  // namespace content
 
 #endif  // CONTENT_PUBLIC_RENDERER_CONTENT_RENDERER_CLIENT_H_
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -3108,16 +3108,23 @@ bool RenderFrameImpl::willCheckAndDispat
 
   Send(new ViewHostMsg_RouteMessageEvent(render_view_->routing_id_, params));
   return true;
 }
 
 blink::WebString RenderFrameImpl::userAgentOverride(blink::WebLocalFrame* frame,
                                                     const blink::WebURL& url) {
   DCHECK(!frame_ || frame_ == frame);
+
+  std::string embedder_override;
+  if (GetContentClient()->renderer()->GetUserAgentOverride(
+      url, &embedder_override)) {
+    return WebString::fromUTF8(embedder_override);
+  }
+
   if (!render_view_->webview() || !render_view_->webview()->mainFrame() ||
       render_view_->renderer_preferences_.user_agent_override.empty()) {
     return blink::WebString();
   }
 
   // If we're in the middle of committing a load, the data source we need
   // will still be provisional.
   WebFrame* main_frame = render_view_->webview()->mainFrame();
