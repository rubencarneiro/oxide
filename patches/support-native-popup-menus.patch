# Description: Support native popup menus in oxide by activating the Android code
#  in Oxide builds
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/content/browser/renderer_host/render_view_host_impl.cc b/content/browser/renderer_host/render_view_host_impl.cc
--- a/content/browser/renderer_host/render_view_host_impl.cc
+++ b/content/browser/renderer_host/render_view_host_impl.cc
@@ -1003,20 +1003,18 @@ bool RenderViewHostImpl::OnMessageReceiv
     IPC_MESSAGE_HANDLER(ViewHostMsg_TakeFocus, OnTakeFocus)
     IPC_MESSAGE_HANDLER(ViewHostMsg_FocusedNodeChanged, OnFocusedNodeChanged)
     IPC_MESSAGE_HANDLER(ViewHostMsg_ClosePage_ACK, OnClosePageACK)
 #if defined(OS_ANDROID)
     IPC_MESSAGE_HANDLER(ViewHostMsg_SelectionRootBoundsChanged,
                         OnSelectionRootBoundsChanged)
 #endif
     IPC_MESSAGE_HANDLER(ViewHostMsg_DidZoomURL, OnDidZoomURL)
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
     IPC_MESSAGE_HANDLER(ViewHostMsg_ShowPopup, OnShowPopup)
     IPC_MESSAGE_HANDLER(ViewHostMsg_HidePopup, OnHidePopup)
-#endif
     IPC_MESSAGE_HANDLER(ViewHostMsg_RunFileChooser, OnRunFileChooser)
     IPC_MESSAGE_HANDLER(AccessibilityHostMsg_Events, OnAccessibilityEvents)
     IPC_MESSAGE_HANDLER(AccessibilityHostMsg_LocationChanges,
                         OnAccessibilityLocationChanges)
     IPC_MESSAGE_HANDLER(ViewHostMsg_FocusedNodeTouched, OnFocusedNodeTouched)
     // Have the super handle all other messages.
     IPC_MESSAGE_UNHANDLED(
         handled = RenderWidgetHostImpl::OnMessageReceived(msg))
@@ -1411,28 +1409,26 @@ void RenderViewHostImpl::ForwardKeyboard
   if (ignore_input_events()) {
     if (key_event.type == WebInputEvent::RawKeyDown)
       delegate_->OnIgnoredUIEvent();
     return;
   }
   RenderWidgetHostImpl::ForwardKeyboardEvent(key_event);
 }
 
-#if defined(OS_ANDROID)
 void RenderViewHostImpl::DidSelectPopupMenuItems(
     const std::vector<int>& selected_indices) {
   Send(new ViewMsg_SelectPopupMenuItems(GetRoutingID(), false,
                                         selected_indices));
 }
 
 void RenderViewHostImpl::DidCancelPopupMenu() {
   Send(new ViewMsg_SelectPopupMenuItems(GetRoutingID(), true,
                                         std::vector<int>()));
 }
-#endif
 
 #if defined(OS_MACOSX)
 void RenderViewHostImpl::DidSelectPopupMenuItem(int selected_index) {
   Send(new ViewMsg_SelectPopupMenuItem(GetRoutingID(), selected_index));
 }
 
 void RenderViewHostImpl::DidCancelPopupMenu() {
   Send(new ViewMsg_SelectPopupMenuItem(GetRoutingID(), -1));
@@ -1617,17 +1613,16 @@ void RenderViewHostImpl::OnFocusedNodeTo
     virtual_keyboard_requested_ = base::win::DisplayVirtualKeyboard();
   } else {
     virtual_keyboard_requested_ = false;
     base::win::DismissVirtualKeyboard();
   }
 #endif
 }
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
 void RenderViewHostImpl::OnShowPopup(
     const ViewHostMsg_ShowPopup_Params& params) {
   RenderViewHostDelegateView* view = delegate_->GetDelegateView();
   if (view) {
     view->ShowPopupMenu(params.bounds,
                         params.item_height,
                         params.item_font_size,
                         params.selected_item,
@@ -1637,17 +1632,16 @@ void RenderViewHostImpl::OnShowPopup(
   }
 }
 
 void RenderViewHostImpl::OnHidePopup() {
   RenderViewHostDelegateView* view = delegate_->GetDelegateView();
   if (view)
     view->HidePopupMenu();
 }
-#endif
 
 void RenderViewHostImpl::SetState(RenderViewHostImplState rvh_state) {
   // We update the number of RenderViews in a SiteInstance when the
   // swapped out status of this RenderView gets flipped to/from live.
   if (!IsRVHStateActive(rvh_state_) && IsRVHStateActive(rvh_state))
     instance_->increment_active_view_count();
   else if (IsRVHStateActive(rvh_state_) && !IsRVHStateActive(rvh_state))
     instance_->decrement_active_view_count();
diff --git a/content/browser/renderer_host/render_view_host_impl.h b/content/browser/renderer_host/render_view_host_impl.h
--- a/content/browser/renderer_host/render_view_host_impl.h
+++ b/content/browser/renderer_host/render_view_host_impl.h
@@ -390,20 +390,20 @@ class CONTENT_EXPORT RenderViewHostImpl
   void DidSelectPopupMenuItem(int selected_index);
   void DidCancelPopupMenu();
 #endif
 
 #if defined(OS_ANDROID)
   BrowserMediaPlayerManager* media_player_manager() {
     return media_player_manager_.get();
   }
+#endif
 
   void DidSelectPopupMenuItems(const std::vector<int>& selected_indices);
   void DidCancelPopupMenu();
-#endif
 
   int main_frame_routing_id() const {
     return main_frame_routing_id_;
   }
 
   // Set the opener to null in the renderer process.
   void DisownOpener();
 
@@ -516,20 +516,18 @@ class CONTENT_EXPORT RenderViewHostImpl
   void OnAccessibilityEvents(
       const std::vector<AccessibilityHostMsg_EventParams>& params);
   void OnAccessibilityLocationChanges(
       const std::vector<AccessibilityHostMsg_LocationChangeParams>& params);
   void OnDidZoomURL(double zoom_level, bool remember, const GURL& url);
   void OnRunFileChooser(const FileChooserParams& params);
   void OnFocusedNodeTouched(bool editable);
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   void OnShowPopup(const ViewHostMsg_ShowPopup_Params& params);
   void OnHidePopup();
-#endif
 
  private:
   // TODO(nasko): Temporarily friend RenderFrameHostImpl, so we don't duplicate
   // utility functions and state needed in both classes, while we move frame
   // specific code away from this class.
   friend class RenderFrameHostImpl;
   friend class TestRenderViewHost;
   FRIEND_TEST_ALL_PREFIXES(RenderViewHostTest, BasicRenderFrameHost);
diff --git a/content/common/view_messages.h b/content/common/view_messages.h
--- a/content/common/view_messages.h
+++ b/content/common/view_messages.h
@@ -918,22 +918,24 @@ IPC_MESSAGE_CONTROL1(ViewMsg_SetWebKitSh
 // they came in, so the renderer can tell if it needs to send updated rects.
 // Otherwise just pass -1 to always receive the list of rects.
 //
 // There must be an active search string (it is probably most useful to call
 // this immediately after a ViewHostMsg_Find_Reply message arrives with
 // final_update set to true).
 IPC_MESSAGE_ROUTED1(ViewMsg_FindMatchRects,
                     int /* current_version */)
+#endif
 
 // External popup menus.
 IPC_MESSAGE_ROUTED2(ViewMsg_SelectPopupMenuItems,
                     bool /* user canceled the popup */,
                     std::vector<int> /* selected indices */)
 
+#if defined(OS_ANDROID)
 // Notifies the renderer whether hiding/showing the top controls is enabled
 // and whether or not to animate to the proper state.
 IPC_MESSAGE_ROUTED3(ViewMsg_UpdateTopControlsState,
                     bool /* enable_hiding */,
                     bool /* enable_showing */,
                     bool /* animate */)
 
 IPC_MESSAGE_ROUTED0(ViewMsg_ShowImeIfNeeded)
@@ -948,18 +950,19 @@ IPC_MESSAGE_ROUTED0(ViewMsg_ImeEventAck)
 
 // Sent by the browser when we should pause video playback.
 IPC_MESSAGE_ROUTED0(ViewMsg_PauseVideo);
 
 // Extracts the data at the given rect, returning it through the
 // ViewHostMsg_SmartClipDataExtracted IPC.
 IPC_MESSAGE_ROUTED1(ViewMsg_ExtractSmartClipData,
                     gfx::Rect /* rect */)
+#endif
 
-#elif defined(OS_MACOSX)
+#if defined(OS_MACOSX)
 // Let the RenderView know its window has changed visibility.
 IPC_MESSAGE_ROUTED1(ViewMsg_SetWindowVisibility,
                     bool /* visibile */)
 
 // Let the RenderView know its window's frame has changed.
 IPC_MESSAGE_ROUTED2(ViewMsg_WindowFrameChanged,
                     gfx::Rect /* window frame */,
                     gfx::Rect /* content view frame */)
@@ -1087,22 +1090,20 @@ IPC_MESSAGE_ROUTED0(ViewHostMsg_Close)
 IPC_MESSAGE_ROUTED0(ViewHostMsg_UpdateScreenRects_ACK)
 
 // Sent by the renderer process to request that the browser move the view.
 // This corresponds to the window.resizeTo() and window.moveTo() APIs, and
 // the browser may ignore this message.
 IPC_MESSAGE_ROUTED1(ViewHostMsg_RequestMove,
                     gfx::Rect /* position */)
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
 // Message to show/hide a popup menu using native controls.
 IPC_MESSAGE_ROUTED1(ViewHostMsg_ShowPopup,
                     ViewHostMsg_ShowPopup_Params)
 IPC_MESSAGE_ROUTED0(ViewHostMsg_HidePopup)
-#endif
 
 // Result of string search in the page.
 // Response to ViewMsg_Find with the results of the requested find-in-page
 // search, the number of matches found and the selection rect (in screen
 // coordinates) for the string found. If |final_update| is false, it signals
 // that this is not the last Find_Reply message - more will be sent as the
 // scoping effort continues.
 IPC_MESSAGE_ROUTED5(ViewHostMsg_Find_Reply,
diff --git a/content/content_renderer.gypi b/content/content_renderer.gypi
--- a/content/content_renderer.gypi
+++ b/content/content_renderer.gypi
@@ -137,16 +137,18 @@
       'renderer/dom_storage/dom_storage_dispatcher.h',
       'renderer/dom_storage/dom_storage_proxy.h',
       'renderer/dom_storage/webstoragearea_impl.cc',
       'renderer/dom_storage/webstoragearea_impl.h',
       'renderer/dom_storage/webstoragenamespace_impl.cc',
       'renderer/dom_storage/webstoragenamespace_impl.h',
       'renderer/drop_data_builder.cc',
       'renderer/drop_data_builder.h',
+      'renderer/external_popup_menu.cc',
+      'renderer/external_popup_menu.h',
       'renderer/fetchers/image_resource_fetcher.cc',
       'renderer/fetchers/image_resource_fetcher.h',
       'renderer/fetchers/multi_resolution_image_resource_fetcher.cc',
       'renderer/fetchers/multi_resolution_image_resource_fetcher.h',
       'renderer/fetchers/resource_fetcher_impl.cc',
       'renderer/fetchers/resource_fetcher_impl.h',
       'renderer/gamepad_shared_memory_reader.cc',
       'renderer/gamepad_shared_memory_reader.h',
diff --git a/content/renderer/external_popup_menu.cc b/content/renderer/external_popup_menu.cc
--- a/content/renderer/external_popup_menu.cc
+++ b/content/renderer/external_popup_menu.cc
@@ -65,21 +65,19 @@ void ExternalPopupMenu::DidSelectItem(in
     return;
   if (index == -1)
     popup_menu_client_->didCancel();
   else
     popup_menu_client_->didAcceptIndex(index);
 }
 #endif
 
-#if defined(OS_ANDROID)
 void ExternalPopupMenu::DidSelectItems(bool canceled,
                                        const std::vector<int>& indices) {
   if (!popup_menu_client_)
     return;
   if (canceled)
     popup_menu_client_->didCancel();
   else
     popup_menu_client_->didAcceptIndices(indices);
 }
-#endif
 
 }  // namespace content
diff --git a/content/renderer/external_popup_menu.h b/content/renderer/external_popup_menu.h
--- a/content/renderer/external_popup_menu.h
+++ b/content/renderer/external_popup_menu.h
@@ -31,20 +31,18 @@ class ExternalPopupMenu : public blink::
       float scale, const gfx::Point& offset);
 
 #if defined(OS_MACOSX)
   // Called when the user has selected an item. |selected_item| is -1 if the
   // user canceled the popup.
   void DidSelectItem(int selected_index);
 #endif
 
-#if defined(OS_ANDROID)
   // Called when the user has selected items or canceled the popup.
   void DidSelectItems(bool canceled, const std::vector<int>& selected_indices);
-#endif
 
   // blink::WebExternalPopupMenu implementation:
   virtual void show(const blink::WebRect& bounds);
   virtual void close();
 
  private:
   RenderViewImpl* render_view_;
   blink::WebPopupMenuInfo popup_menu_info_;
diff --git a/content/renderer/render_thread_impl.cc b/content/renderer/render_thread_impl.cc
--- a/content/renderer/render_thread_impl.cc
+++ b/content/renderer/render_thread_impl.cc
@@ -327,20 +327,18 @@ void RenderThreadImpl::Init() {
   base::debug::TraceLog::GetInstance()->SetThreadSortIndex(
       base::PlatformThread::CurrentId(),
       kTraceEventRendererMainThreadSortIndex);
 
   v8::V8::SetCounterFunction(base::StatsTable::FindLocation);
   v8::V8::SetCreateHistogramFunction(CreateHistogram);
   v8::V8::SetAddHistogramSampleFunction(AddHistogramSample);
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   // On Mac and Android, the select popups are rendered by the browser.
   blink::WebView::setUseExternalPopupMenus(true);
-#endif
 
   lazy_tls.Pointer()->Set(this);
 
   // Register this object as the main thread.
   ChildProcess::current()->set_main_thread(this);
 
   // In single process the single process is all there is.
   suspend_webkit_shared_timer_ = true;
diff --git a/content/renderer/render_view_impl.cc b/content/renderer/render_view_impl.cc
--- a/content/renderer/render_view_impl.cc
+++ b/content/renderer/render_view_impl.cc
@@ -1133,22 +1133,25 @@ bool RenderViewImpl::OnMessageReceived(c
                         OnReleaseDisambiguationPopupBitmap)
     IPC_MESSAGE_HANDLER(ViewMsg_WindowSnapshotCompleted,
                         OnWindowSnapshotCompleted)
     IPC_MESSAGE_HANDLER(ViewMsg_SelectWordAroundCaret, OnSelectWordAroundCaret)
 #if defined(OS_ANDROID)
     IPC_MESSAGE_HANDLER(InputMsg_ActivateNearestFindResult,
                         OnActivateNearestFindResult)
     IPC_MESSAGE_HANDLER(ViewMsg_FindMatchRects, OnFindMatchRects)
+#endif
     IPC_MESSAGE_HANDLER(ViewMsg_SelectPopupMenuItems, OnSelectPopupMenuItems)
+#if defined(OS_ANDROID)
     IPC_MESSAGE_HANDLER(ViewMsg_UpdateTopControlsState,
                         OnUpdateTopControlsState)
     IPC_MESSAGE_HANDLER(ViewMsg_PauseVideo, OnPauseVideo)
     IPC_MESSAGE_HANDLER(ViewMsg_ExtractSmartClipData, OnExtractSmartClipData)
-#elif defined(OS_MACOSX)
+#endif
+#if defined(OS_MACOSX)
     IPC_MESSAGE_HANDLER(ViewMsg_PluginImeCompositionCompleted,
                         OnPluginImeCompositionCompleted)
     IPC_MESSAGE_HANDLER(ViewMsg_SelectPopupMenuItem, OnSelectPopupMenuItem)
     IPC_MESSAGE_HANDLER(ViewMsg_SetInLiveResize, OnSetInLiveResize)
     IPC_MESSAGE_HANDLER(ViewMsg_SetWindowVisibility, OnSetWindowVisibility)
     IPC_MESSAGE_HANDLER(ViewMsg_WindowFrameChanged, OnWindowFrameChanged)
 #endif
     // Adding a new message? Add platform independent ones first, then put the
@@ -1497,17 +1500,17 @@ WebWidget* RenderViewImpl::createPopupMe
         screen_metrics_emulator_.get());
   }
   return widget->webwidget();
 }
 
 WebExternalPopupMenu* RenderViewImpl::createExternalPopupMenu(
     const WebPopupMenuInfo& popup_menu_info,
     WebExternalPopupMenuClient* popup_menu_client) {
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
+#if 1
   // An IPC message is sent to the browser to build and display the actual
   // popup.  The user could have time to click a different select by the time
   // the popup is shown.  In that case external_popup_menu_ is non NULL.
   // By returning NULL in that case, we instruct WebKit to cancel that new
   // popup.  So from the user perspective, only the first one will show, and
   // will have to close the first one before another one can be shown.
   if (external_popup_menu_)
     return NULL;
@@ -3836,39 +3839,35 @@ void RenderViewImpl::DismissDateTimeDial
 void RenderViewImpl::OnSelectPopupMenuItem(int selected_index) {
   if (external_popup_menu_ == NULL)
     return;
   external_popup_menu_->DidSelectItem(selected_index);
   external_popup_menu_.reset();
 }
 #endif
 
-#if defined(OS_ANDROID)
 void RenderViewImpl::OnSelectPopupMenuItems(
     bool canceled,
     const std::vector<int>& selected_indices) {
   // It is possible to receive more than one of these calls if the user presses
   // a select faster than it takes for the show-select-popup IPC message to make
   // it to the browser UI thread.  Ignore the extra-messages.
   // TODO(jcivelli): http:/b/5793321 Implement a better fix, as detailed in bug.
   if (!external_popup_menu_)
     return;
 
   external_popup_menu_->DidSelectItems(canceled, selected_indices);
   external_popup_menu_.reset();
 }
-#endif
-
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
+
 void RenderViewImpl::DidHideExternalPopupMenu() {
   // We need to clear external_popup_menu_ as soon as ExternalPopupMenu::close
   // is called. Otherwise, createExternalPopupMenu() for new popup will fail.
   external_popup_menu_.reset();
 }
-#endif
 
 void RenderViewImpl::OnShowContextMenu(const gfx::Point& location) {
   context_menu_source_type_ = ui::MENU_SOURCE_TOUCH_EDIT_MENU;
   touch_editing_context_menu_location_ = location;
   if (webview())
     webview()->showContextMenu();
 }
 
diff --git a/content/renderer/render_view_impl.h b/content/renderer/render_view_impl.h
--- a/content/renderer/render_view_impl.h
+++ b/content/renderer/render_view_impl.h
@@ -265,19 +265,17 @@ class CONTENT_EXPORT RenderViewImpl
   // Returns true if the chooser was successfully scheduled. False means we
   // didn't schedule anything.
   bool ScheduleFileChooser(const FileChooserParams& params,
                            blink::WebFileChooserCompletion* completion);
 
 #if defined(OS_ANDROID)
   void DismissDateTimeDialog();
 #endif
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   void DidHideExternalPopupMenu();
-#endif
 
   bool is_loading() const { return frames_in_progress_ != 0; }
 
   void FrameDidStartLoading(blink::WebFrame* frame);
   void FrameDidStopLoading(blink::WebFrame* frame);
 
   void FrameDidCommitProvisionalLoad(blink::WebLocalFrame* frame,
                                      bool is_new_navigation);
@@ -765,26 +763,29 @@ class CONTENT_EXPORT RenderViewImpl
   void OnEnableViewSourceMode();
   void OnDisownOpener();
   void OnWindowSnapshotCompleted(const int snapshot_id,
       const gfx::Size& size, const std::vector<unsigned char>& png);
   void OnSelectWordAroundCaret();
 #if defined(OS_ANDROID)
   void OnActivateNearestFindResult(int request_id, float x, float y);
   void OnFindMatchRects(int current_version);
+#endif
   void OnSelectPopupMenuItems(bool canceled,
                               const std::vector<int>& selected_indices);
+#if defined(OS_ANDROID)
   void OnUndoScrollFocusedEditableNodeIntoRect();
   void OnUpdateTopControlsState(bool enable_hiding,
                                 bool enable_showing,
                                 bool animate);
   void OnPauseVideo();
   void OnExtractSmartClipData(const gfx::Rect& rect);
   void GetSelectionRootBounds(gfx::Rect* bounds) const;
-#elif defined(OS_MACOSX)
+#endif
+#if defined(OS_MACOSX)
   void OnPluginImeCompositionCompleted(const base::string16& text,
                                        int plugin_id);
   void OnSelectPopupMenuItem(int selected_index);
   void OnSetInLiveResize(bool in_live_resize);
   void OnSetWindowVisibility(bool visible);
   void OnWindowFrameChanged(const gfx::Rect& window_frame,
                             const gfx::Rect& view_frame);
 #endif
@@ -1171,20 +1172,18 @@ class CONTENT_EXPORT RenderViewImpl
   // is passed to us upon creation.  WebKit asks for this ID upon first use and
   // uses it whenever asking the browser process to allocate new storage areas.
   int64 session_storage_namespace_id_;
 
   // Stores edit commands associated to the next key event.
   // Shall be cleared as soon as the next key event is processed.
   EditCommands edit_commands_;
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   // The external popup for the currently showing select popup.
   scoped_ptr<ExternalPopupMenu> external_popup_menu_;
-#endif
 
   // All the registered observers.  We expect this list to be small, so vector
   // is fine.
   ObserverList<RenderViewObserver> observers_;
 
   // Wraps the |webwidget_| as a MouseLockDispatcher::LockTarget interface.
   scoped_ptr<MouseLockDispatcher::LockTarget> webwidget_mouse_lock_target_;
 
diff --git a/content/renderer/render_widget.cc b/content/renderer/render_widget.cc
--- a/content/renderer/render_widget.cc
+++ b/content/renderer/render_widget.cc
@@ -541,23 +541,21 @@ void RenderWidget::SetPopupOriginAdjustm
 void RenderWidget::SetScreenMetricsEmulationParameters(
     float device_scale_factor,
     const gfx::Point& root_layer_offset,
     float root_layer_scale) {
   // This is only supported in RenderView.
   NOTREACHED();
 }
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
 void RenderWidget::SetExternalPopupOriginAdjustmentsForEmulation(
     ExternalPopupMenu* popup, ScreenMetricsEmulator* emulator) {
   popup->SetOriginScaleAndOffsetForEmulation(
       emulator->scale(), emulator->offset());
 }
-#endif
 
 void RenderWidget::OnShowHostContextMenu(ContextMenuParams* params) {
   if (screen_metrics_emulator_)
     screen_metrics_emulator_->OnShowContextMenu(params);
 }
 
 void RenderWidget::ScheduleCompositeWithForcedRedraw() {
   if (compositor_) {
diff --git a/content/renderer/render_widget.h b/content/renderer/render_widget.h
--- a/content/renderer/render_widget.h
+++ b/content/renderer/render_widget.h
@@ -310,20 +310,18 @@ class CONTENT_EXPORT RenderWidget
               bool is_fullscreen,
               ResizeAck resize_ack);
   // Used to force the size of a window when running layout tests.
   void ResizeSynchronously(const gfx::Rect& new_position);
   virtual void SetScreenMetricsEmulationParameters(
       float device_scale_factor,
       const gfx::Point& root_layer_offset,
       float root_layer_scale);
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   void SetExternalPopupOriginAdjustmentsForEmulation(
       ExternalPopupMenu* popup, ScreenMetricsEmulator* emulator);
-#endif
 
   // RenderWidget IPC message handlers
   void OnHandleInputEvent(const blink::WebInputEvent* event,
                           const ui::LatencyInfo& latency_info,
                           bool keyboard_shortcut);
   void OnCursorVisibilityChange(bool is_visible);
   void OnMouseCaptureLost();
   virtual void OnSetFocus(bool enable);
