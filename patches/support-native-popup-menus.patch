# Description: Support native popup menus in oxide by activating the Android code
#  in Oxide builds
# Author: Chris Coulson <chris.coulson@canonical.com>

diff --git a/content/browser/frame_host/render_frame_host_impl.cc b/content/browser/frame_host/render_frame_host_impl.cc
--- a/content/browser/frame_host/render_frame_host_impl.cc
+++ b/content/browser/frame_host/render_frame_host_impl.cc
@@ -374,20 +374,18 @@ bool RenderFrameHostImpl::OnMessageRecei
                         OnShowDesktopNotification)
     IPC_MESSAGE_HANDLER(DesktopNotificationHostMsg_Cancel,
                         OnCancelDesktopNotification)
     IPC_MESSAGE_HANDLER(FrameHostMsg_TextSurroundingSelectionResponse,
                         OnTextSurroundingSelectionResponse)
     IPC_MESSAGE_HANDLER(AccessibilityHostMsg_Events, OnAccessibilityEvents)
     IPC_MESSAGE_HANDLER(AccessibilityHostMsg_LocationChanges,
                         OnAccessibilityLocationChanges)
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
     IPC_MESSAGE_HANDLER(FrameHostMsg_ShowPopup, OnShowPopup)
     IPC_MESSAGE_HANDLER(FrameHostMsg_HidePopup, OnHidePopup)
-#endif
   IPC_END_MESSAGE_MAP()
 
   return handled;
 }
 
 void RenderFrameHostImpl::AccessibilitySetFocus(int object_id) {
   Send(new AccessibilityMsg_SetFocus(routing_id_, object_id));
 }
@@ -1098,17 +1096,16 @@ void RenderFrameHostImpl::OnAccessibilit
       }
       if (browser_accessibility_manager_)
         browser_accessibility_manager_->OnLocationChanges(params);
     }
     // TODO(aboxhall): send location change events to web contents observers too
   }
 }
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
 void RenderFrameHostImpl::OnShowPopup(
     const FrameHostMsg_ShowPopup_Params& params) {
   RenderViewHostDelegateView* view =
       render_view_host_->delegate_->GetDelegateView();
   if (view) {
     view->ShowPopupMenu(this,
                         params.bounds,
                         params.item_height,
@@ -1121,17 +1118,16 @@ void RenderFrameHostImpl::OnShowPopup(
 }
 
 void RenderFrameHostImpl::OnHidePopup() {
   RenderViewHostDelegateView* view =
       render_view_host_->delegate_->GetDelegateView();
   if (view)
     view->HidePopupMenu();
 }
-#endif
 
 void RenderFrameHostImpl::SetPendingShutdown(const base::Closure& on_swap_out) {
   render_view_host_->SetPendingShutdown(on_swap_out);
 }
 
 bool RenderFrameHostImpl::CanCommitURL(const GURL& url) {
   // TODO(creis): We should also check for WebUI pages here.  Also, when the
   // out-of-process iframes implementation is ready, we should check for
@@ -1349,29 +1345,28 @@ RenderFrameHostImpl::GetParentNativeView
 void RenderFrameHostImpl::DidSelectPopupMenuItem(int selected_index) {
   Send(new FrameMsg_SelectPopupMenuItem(routing_id_, selected_index));
 }
 
 void RenderFrameHostImpl::DidCancelPopupMenu() {
   Send(new FrameMsg_SelectPopupMenuItem(routing_id_, -1));
 }
 
-#elif defined(OS_ANDROID)
+#endif
 
 void RenderFrameHostImpl::DidSelectPopupMenuItems(
     const std::vector<int>& selected_indices) {
   Send(new FrameMsg_SelectPopupMenuItems(routing_id_, false, selected_indices));
 }
 
 void RenderFrameHostImpl::DidCancelPopupMenu() {
   Send(new FrameMsg_SelectPopupMenuItems(
       routing_id_, true, std::vector<int>()));
 }
 
-#endif
 
 void RenderFrameHostImpl::ClearPendingTransitionRequestData() {
   BrowserThread::PostTask(
       BrowserThread::IO,
       FROM_HERE,
       base::Bind(
           &TransitionRequestManager::ClearPendingTransitionRequestData,
           base::Unretained(TransitionRequestManager::GetInstance()),
diff --git a/content/browser/frame_host/render_frame_host_impl.h b/content/browser/frame_host/render_frame_host_impl.h
--- a/content/browser/frame_host/render_frame_host_impl.h
+++ b/content/browser/frame_host/render_frame_host_impl.h
@@ -27,19 +27,17 @@
 
 class GURL;
 struct AccessibilityHostMsg_EventParams;
 struct AccessibilityHostMsg_LocationChangeParams;
 struct FrameHostMsg_DidFailProvisionalLoadWithError_Params;
 struct FrameHostMsg_OpenURL_Params;
 struct FrameHostMsg_BeginNavigation_Params;
 struct FrameMsg_Navigate_Params;
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
 struct FrameHostMsg_ShowPopup_Params;
-#endif
 
 namespace base {
 class FilePath;
 class ListValue;
 }
 
 namespace content {
 
@@ -279,20 +277,19 @@ class CONTENT_EXPORT RenderFrameHostImpl
 #if defined(OS_WIN)
   void SetParentNativeViewAccessible(
       gfx::NativeViewAccessible accessible_parent);
   gfx::NativeViewAccessible GetParentNativeViewAccessible() const;
 #elif defined(OS_MACOSX)
   // Select popup menu related methods (for external popup menus).
   void DidSelectPopupMenuItem(int selected_index);
   void DidCancelPopupMenu();
-#elif defined(OS_ANDROID)
+#endif
   void DidSelectPopupMenuItems(const std::vector<int>& selected_indices);
   void DidCancelPopupMenu();
-#endif
 
  protected:
   friend class RenderFrameHostFactory;
 
   // TODO(nasko): Remove dependency on RenderViewHost here. RenderProcessHost
   // should be the abstraction needed here, but we need RenderViewHost to pass
   // into WebContentsObserver::FrameDetached for now.
   RenderFrameHostImpl(RenderViewHostImpl* render_view_host,
@@ -361,20 +358,18 @@ class CONTENT_EXPORT RenderFrameHostImpl
   void OnUpdateEncoding(const std::string& encoding);
   void OnBeginNavigation(
       const FrameHostMsg_BeginNavigation_Params& params);
   void OnAccessibilityEvents(
       const std::vector<AccessibilityHostMsg_EventParams>& params);
   void OnAccessibilityLocationChanges(
       const std::vector<AccessibilityHostMsg_LocationChangeParams>& params);
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   void OnShowPopup(const FrameHostMsg_ShowPopup_Params& params);
   void OnHidePopup();
-#endif
 
   // Returns whether the given URL is allowed to commit in the current process.
   // This is a more conservative check than RenderProcessHost::FilterURL, since
   // it will be used to kill processes that commit unauthorized URLs.
   bool CanCommitURL(const GURL& url);
 
   void PlatformNotificationPermissionRequestDone(
       int request_id, blink::WebNotificationPermission permission);
diff --git a/content/browser/renderer_host/render_view_host_delegate_view.h b/content/browser/renderer_host/render_view_host_delegate_view.h
--- a/content/browser/renderer_host/render_view_host_delegate_view.h
+++ b/content/browser/renderer_host/render_view_host_delegate_view.h
@@ -54,32 +54,30 @@ class CONTENT_EXPORT RenderViewHostDeleg
   // Notification that view for this delegate got the focus.
   virtual void GotFocus() {}
 
   // Callback to inform the browser that the page is returning the focus to
   // the browser's chrome. If reverse is true, it means the focus was
   // retrieved by doing a Shift-Tab.
   virtual void TakeFocus(bool reverse) {}
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   // Shows a popup menu with the specified items.
   // This method should call RenderFrameHost::DidSelectPopupMenuItem[s]() or
   // RenderFrameHost::DidCancelPopupMenu() based on the user action.
   virtual void ShowPopupMenu(RenderFrameHost* render_frame_host,
                              const gfx::Rect& bounds,
                              int item_height,
                              double item_font_size,
                              int selected_item,
                              const std::vector<MenuItem>& items,
                              bool right_aligned,
                              bool allow_multiple_selection) {};
 
   // Hides a popup menu opened by ShowPopupMenu().
   virtual void HidePopupMenu() {};
-#endif
 
  protected:
   virtual ~RenderViewHostDelegateView() {}
 };
 
 }  // namespace content
 
 #endif  // CONTENT_BROWSER_RENDERER_HOST_RENDER_VIEW_HOST_DELEGATE_VIEW_H_
diff --git a/content/common/frame_messages.h b/content/common/frame_messages.h
--- a/content/common/frame_messages.h
+++ b/content/common/frame_messages.h
@@ -300,17 +300,16 @@ IPC_STRUCT_BEGIN(FrameHostMsg_BeginNavig
   // Whether this navigation should replace the current session history entry on
   // commit.
   IPC_STRUCT_MEMBER(bool, should_replace_current_entry)
 
   // Whether or not we should allow the URL to download.
   IPC_STRUCT_MEMBER(bool, allow_download)
 IPC_STRUCT_END()
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
 // This message is used for supporting popup menus on Mac OS X and Android using
 // native controls. See the FrameHostMsg_ShowPopup message.
 IPC_STRUCT_BEGIN(FrameHostMsg_ShowPopup_Params)
   // Position on the screen.
   IPC_STRUCT_MEMBER(gfx::Rect, bounds)
 
   // The height of each item in the menu.
   IPC_STRUCT_MEMBER(int, item_height)
@@ -325,17 +324,16 @@ IPC_STRUCT_BEGIN(FrameHostMsg_ShowPopup_
   IPC_STRUCT_MEMBER(std::vector<content::MenuItem>, popup_items)
 
   // Whether items should be right-aligned.
   IPC_STRUCT_MEMBER(bool, right_aligned)
 
   // Whether this is a multi-select popup.
   IPC_STRUCT_MEMBER(bool, allow_multiple_selection)
 IPC_STRUCT_END()
-#endif
 
 // -----------------------------------------------------------------------------
 // Messages sent from the browser to the renderer.
 
 // When HW accelerated buffers are swapped in an out-of-process child frame
 // renderer, the message is forwarded to the embedding frame to notify it of
 // a new texture available for compositing. When the buffer has finished
 // presenting, a FrameHostMsg_BuffersSwappedACK should be sent back to
@@ -468,24 +466,22 @@ IPC_MESSAGE_ROUTED1(FrameMsg_TextSurroun
 // Tells the renderer to insert a link to the specified stylesheet. This is
 // needed to support navigation transitions.
 IPC_MESSAGE_ROUTED1(FrameMsg_AddStyleSheetByURL, std::string)
 
 // Change the accessibility mode in the renderer process.
 IPC_MESSAGE_ROUTED1(FrameMsg_SetAccessibilityMode,
                     AccessibilityMode)
 
-#if defined(OS_ANDROID)
-
 // External popup menus.
 IPC_MESSAGE_ROUTED2(FrameMsg_SelectPopupMenuItems,
                     bool /* user canceled the popup */,
                     std::vector<int> /* selected indices */)
 
-#elif defined(OS_MACOSX)
+#if defined(OS_MACOSX)
 
 // External popup menus.
 IPC_MESSAGE_ROUTED1(FrameMsg_SelectPopupMenuItem,
                     int /* selected index, -1 means no selection */)
 
 #endif
 
 // -----------------------------------------------------------------------------
@@ -767,16 +763,12 @@ IPC_MESSAGE_CONTROL4(FrameHostMsg_AddNav
 // Tells the browser to perform a navigation.
 IPC_MESSAGE_ROUTED1(FrameHostMsg_BeginNavigation,
                     FrameHostMsg_BeginNavigation_Params)
 
 // Sent once a paint happens after the first non empty layout. In other words
 // after the frame has painted something.
 IPC_MESSAGE_ROUTED0(FrameHostMsg_DidFirstVisuallyNonEmptyPaint)
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
-
 // Message to show/hide a popup menu using native controls.
 IPC_MESSAGE_ROUTED1(FrameHostMsg_ShowPopup,
                     FrameHostMsg_ShowPopup_Params)
 IPC_MESSAGE_ROUTED0(FrameHostMsg_HidePopup)
-
-#endif
diff --git a/content/common/view_messages.h b/content/common/view_messages.h
--- a/content/common/view_messages.h
+++ b/content/common/view_messages.h
@@ -899,18 +899,19 @@ IPC_MESSAGE_ROUTED1(ViewMsg_BeginFrame,
 // Sent by the browser when an IME update that requires acknowledgement has been
 // processed on the browser side.
 IPC_MESSAGE_ROUTED0(ViewMsg_ImeEventAck)
 
 // Extracts the data at the given rect, returning it through the
 // ViewHostMsg_SmartClipDataExtracted IPC.
 IPC_MESSAGE_ROUTED1(ViewMsg_ExtractSmartClipData,
                     gfx::Rect /* rect */)
+#endif
 
-#elif defined(OS_MACOSX)
+#if defined(OS_MACOSX)
 // Let the RenderView know its window has changed visibility.
 IPC_MESSAGE_ROUTED1(ViewMsg_SetWindowVisibility,
                     bool /* visibile */)
 
 // Let the RenderView know its window's frame has changed.
 IPC_MESSAGE_ROUTED2(ViewMsg_WindowFrameChanged,
                     gfx::Rect /* window frame */,
                     gfx::Rect /* content view frame */)
diff --git a/content/content_renderer.gypi b/content/content_renderer.gypi
--- a/content/content_renderer.gypi
+++ b/content/content_renderer.gypi
@@ -146,16 +146,18 @@
       'renderer/dom_storage/webstoragearea_impl.cc',
       'renderer/dom_storage/webstoragearea_impl.h',
       'renderer/dom_storage/webstoragenamespace_impl.cc',
       'renderer/dom_storage/webstoragenamespace_impl.h',
       'renderer/dom_utils.cc',
       'renderer/dom_utils.h',
       'renderer/drop_data_builder.cc',
       'renderer/drop_data_builder.h',
+      'renderer/external_popup_menu.cc',
+      'renderer/external_popup_menu.h',
       'renderer/fetchers/image_resource_fetcher.cc',
       'renderer/fetchers/image_resource_fetcher.h',
       'renderer/fetchers/manifest_fetcher.cc',
       'renderer/fetchers/manifest_fetcher.h',
       'renderer/fetchers/multi_resolution_image_resource_fetcher.cc',
       'renderer/fetchers/multi_resolution_image_resource_fetcher.h',
       'renderer/fetchers/resource_fetcher_impl.cc',
       'renderer/fetchers/resource_fetcher_impl.h',
diff --git a/content/renderer/external_popup_menu.cc b/content/renderer/external_popup_menu.cc
--- a/content/renderer/external_popup_menu.cc
+++ b/content/renderer/external_popup_menu.cc
@@ -66,21 +66,19 @@ void ExternalPopupMenu::DidSelectItem(in
     return;
   if (index == -1)
     popup_menu_client_->didCancel();
   else
     popup_menu_client_->didAcceptIndex(index);
 }
 #endif
 
-#if defined(OS_ANDROID)
 void ExternalPopupMenu::DidSelectItems(bool canceled,
                                        const std::vector<int>& indices) {
   if (!popup_menu_client_)
     return;
   if (canceled)
     popup_menu_client_->didCancel();
   else
     popup_menu_client_->didAcceptIndices(indices);
 }
-#endif
 
 }  // namespace content
diff --git a/content/renderer/external_popup_menu.h b/content/renderer/external_popup_menu.h
--- a/content/renderer/external_popup_menu.h
+++ b/content/renderer/external_popup_menu.h
@@ -31,20 +31,18 @@ class ExternalPopupMenu : public blink::
       float scale, const gfx::Point& offset);
 
 #if defined(OS_MACOSX)
   // Called when the user has selected an item. |selected_item| is -1 if the
   // user canceled the popup.
   void DidSelectItem(int selected_index);
 #endif
 
-#if defined(OS_ANDROID)
   // Called when the user has selected items or canceled the popup.
   void DidSelectItems(bool canceled, const std::vector<int>& selected_indices);
-#endif
 
   // blink::WebExternalPopupMenu implementation:
   virtual void show(const blink::WebRect& bounds);
   virtual void close();
 
  private:
   RenderFrameImpl* render_frame_;
   blink::WebPopupMenuInfo popup_menu_info_;
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -722,23 +722,21 @@ bool RenderFrameImpl::Send(IPC::Message*
     // messages, so don't use the proxy.
     if (render_frame_proxy_ && message->routing_id() == routing_id_)
       return render_frame_proxy_->Send(message);
   }
 
   return RenderThread::Get()->Send(message);
 }
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
 void RenderFrameImpl::DidHideExternalPopupMenu() {
   // We need to clear external_popup_menu_ as soon as ExternalPopupMenu::close
   // is called. Otherwise, createExternalPopupMenu() for new popup will fail.
   external_popup_menu_.reset();
 }
-#endif
 
 bool RenderFrameImpl::OnMessageReceived(const IPC::Message& msg) {
   // TODO(kenrb): document() should not be null, but as a transitional step
   // we have RenderFrameProxy 'wrapping' a RenderFrameImpl, passing messages
   // to this method. This happens for a top-level remote frame, where a
   // document-less RenderFrame is replaced by a RenderFrameProxy but kept
   // around and is still able to receive messages.
   if (!frame_->document().isNull())
@@ -788,19 +786,18 @@ bool RenderFrameImpl::OnMessageReceived(
     IPC_MESSAGE_HANDLER(FrameMsg_Reload, OnReload)
     IPC_MESSAGE_HANDLER(FrameMsg_TextSurroundingSelectionRequest,
                         OnTextSurroundingSelectionRequest)
     IPC_MESSAGE_HANDLER(FrameMsg_AddStyleSheetByURL,
                         OnAddStyleSheetByURL)
     IPC_MESSAGE_HANDLER(FrameMsg_SetAccessibilityMode,
                         OnSetAccessibilityMode)
     IPC_MESSAGE_HANDLER(FrameMsg_DisownOpener, OnDisownOpener)
-#if defined(OS_ANDROID)
     IPC_MESSAGE_HANDLER(FrameMsg_SelectPopupMenuItems, OnSelectPopupMenuItems)
-#elif defined(OS_MACOSX)
+#if defined(OS_MACOSX)
     IPC_MESSAGE_HANDLER(FrameMsg_SelectPopupMenuItem, OnSelectPopupMenuItem)
     IPC_MESSAGE_HANDLER(InputMsg_CopyToFindPboard, OnCopyToFindPboard)
 #endif
   IPC_END_MESSAGE_MAP()
 
   return handled;
 }
 
@@ -1324,31 +1321,29 @@ void RenderFrameImpl::OnDisownOpener() {
   // disowning the opener on subframes, we will need to move WebContentsImpl's
   // opener_ to FrameTreeNode.
   CHECK(!frame_->parent());
 
   if (frame_->opener())
     frame_->setOpener(NULL);
 }
 
-#if defined(OS_ANDROID)
 void RenderFrameImpl::OnSelectPopupMenuItems(
     bool canceled,
     const std::vector<int>& selected_indices) {
   // It is possible to receive more than one of these calls if the user presses
   // a select faster than it takes for the show-select-popup IPC message to make
   // it to the browser UI thread. Ignore the extra-messages.
   // TODO(jcivelli): http:/b/5793321 Implement a better fix, as detailed in bug.
   if (!external_popup_menu_)
     return;
 
   external_popup_menu_->DidSelectItems(canceled, selected_indices);
   external_popup_menu_.reset();
 }
-#endif
 
 #if defined(OS_MACOSX)
 void RenderFrameImpl::OnSelectPopupMenuItem(int selected_index) {
   if (external_popup_menu_ == NULL)
     return;
   external_popup_menu_->DidSelectItem(selected_index);
   external_popup_menu_.reset();
 }
@@ -1657,17 +1652,17 @@ RenderFrameImpl::createWorkerPermissionC
   DCHECK(!frame_ || frame_ == frame);
   return GetContentClient()->renderer()->CreateWorkerPermissionClientProxy(
       this, frame);
 }
 
 WebExternalPopupMenu* RenderFrameImpl::createExternalPopupMenu(
     const WebPopupMenuInfo& popup_menu_info,
     WebExternalPopupMenuClient* popup_menu_client) {
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
+#if 1
   // An IPC message is sent to the browser to build and display the actual
   // popup. The user could have time to click a different select by the time
   // the popup is shown. In that case external_popup_menu_ is non NULL.
   // By returning NULL in that case, we instruct Blink to cancel that new
   // popup. So from the user perspective, only the first one will show, and
   // will have to close the first one before another one can be shown.
   if (external_popup_menu_)
     return NULL;
diff --git a/content/renderer/render_frame_impl.h b/content/renderer/render_frame_impl.h
--- a/content/renderer/render_frame_impl.h
+++ b/content/renderer/render_frame_impl.h
@@ -231,19 +231,17 @@ class CONTENT_EXPORT RenderFrameImpl
     const gfx::Range& replacement_range,
     bool keep_selection);
 #endif  // ENABLE_PLUGINS
 
   // May return NULL in some cases, especially if userMediaClient() returns
   // NULL.
   MediaStreamDispatcher* GetMediaStreamDispatcher();
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   void DidHideExternalPopupMenu();
-#endif
 
   // IPC::Sender
   virtual bool Send(IPC::Message* msg) OVERRIDE;
 
   // IPC::Listener
   virtual bool OnMessageReceived(const IPC::Message& msg) OVERRIDE;
 
   // RenderFrame implementation:
@@ -528,20 +526,19 @@ class CONTENT_EXPORT RenderFrameImpl
   void OnExtendSelectionAndDelete(int before, int after);
   void OnReload(bool ignore_cache);
   void OnTextSurroundingSelectionRequest(size_t max_length);
   void OnAddStyleSheetByURL(const std::string& url);
   void OnSetupTransitionView(const std::string& markup);
   void OnBeginExitTransition(const std::string& css_selector);
   void OnSetAccessibilityMode(AccessibilityMode new_mode);
   void OnDisownOpener();
-#if defined(OS_ANDROID)
   void OnSelectPopupMenuItems(bool canceled,
                               const std::vector<int>& selected_indices);
-#elif defined(OS_MACOSX)
+#if defined(OS_MACOSX)
   void OnSelectPopupMenuItem(int selected_index);
   void OnCopyToFindPboard();
 #endif
 
   // Virtual since overridden by WebTestProxy for layout tests.
   virtual blink::WebNavigationPolicy DecidePolicyForNavigation(
       RenderFrame* render_frame,
       const NavigationPolicyInfo& info);
@@ -731,20 +728,18 @@ class CONTENT_EXPORT RenderFrameImpl
 
   // The current accessibility mode.
   AccessibilityMode accessibility_mode_;
 
   // Only valid if |accessibility_mode_| is anything other than
   // AccessibilityModeOff.
   RendererAccessibility* renderer_accessibility_;
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   // The external popup for the currently showing select popup.
   scoped_ptr<ExternalPopupMenu> external_popup_menu_;
-#endif
 
   base::WeakPtrFactory<RenderFrameImpl> weak_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(RenderFrameImpl);
 };
 
 }  // namespace content
 
diff --git a/content/renderer/render_thread_impl.cc b/content/renderer/render_thread_impl.cc
--- a/content/renderer/render_thread_impl.cc
+++ b/content/renderer/render_thread_impl.cc
@@ -398,20 +398,18 @@ RenderThreadImpl::RenderThreadImpl(const
 
 void RenderThreadImpl::Init() {
   TRACE_EVENT_BEGIN_ETW("RenderThreadImpl::Init", 0, "");
 
   base::debug::TraceLog::GetInstance()->SetThreadSortIndex(
       base::PlatformThread::CurrentId(),
       kTraceEventRendererMainThreadSortIndex);
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   // On Mac and Android, the select popups are rendered by the browser.
   blink::WebView::setUseExternalPopupMenus(true);
-#endif
 
   lazy_tls.Pointer()->Set(this);
 
   // Register this object as the main thread.
   ChildProcess::current()->set_main_thread(this);
 
   // In single process the single process is all there is.
   suspend_webkit_shared_timer_ = true;
diff --git a/content/renderer/render_widget.cc b/content/renderer/render_widget.cc
--- a/content/renderer/render_widget.cc
+++ b/content/renderer/render_widget.cc
@@ -563,23 +563,21 @@ gfx::Rect RenderWidget::AdjustValidation
 void RenderWidget::SetScreenMetricsEmulationParameters(
     float device_scale_factor,
     const gfx::Point& root_layer_offset,
     float root_layer_scale) {
   // This is only supported in RenderView.
   NOTREACHED();
 }
 
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
 void RenderWidget::SetExternalPopupOriginAdjustmentsForEmulation(
     ExternalPopupMenu* popup, ScreenMetricsEmulator* emulator) {
   popup->SetOriginScaleAndOffsetForEmulation(
       emulator->scale(), emulator->offset());
 }
-#endif
 
 void RenderWidget::OnShowHostContextMenu(ContextMenuParams* params) {
   if (screen_metrics_emulator_)
     screen_metrics_emulator_->OnShowContextMenu(params);
 }
 
 void RenderWidget::ScheduleCompositeWithForcedRedraw() {
   if (compositor_) {
diff --git a/content/renderer/render_widget.h b/content/renderer/render_widget.h
--- a/content/renderer/render_widget.h
+++ b/content/renderer/render_widget.h
@@ -353,20 +353,18 @@ class CONTENT_EXPORT RenderWidget
               bool is_fullscreen,
               ResizeAck resize_ack);
   // Used to force the size of a window when running layout tests.
   void ResizeSynchronously(const gfx::Rect& new_position);
   virtual void SetScreenMetricsEmulationParameters(
       float device_scale_factor,
       const gfx::Point& root_layer_offset,
       float root_layer_scale);
-#if defined(OS_MACOSX) || defined(OS_ANDROID)
   void SetExternalPopupOriginAdjustmentsForEmulation(
       ExternalPopupMenu* popup, ScreenMetricsEmulator* emulator);
-#endif
 
   // RenderWidget IPC message handlers
   void OnHandleInputEvent(const blink::WebInputEvent* event,
                           const ui::LatencyInfo& latency_info,
                           bool keyboard_shortcut);
   void OnCursorVisibilityChange(bool is_visible);
   void OnMouseCaptureLost();
   virtual void OnSetFocus(bool enable);
